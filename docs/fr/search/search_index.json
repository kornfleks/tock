{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Bienvenue dans la documentation de Tock! \u00b6 Pr\u00e9sentation \u00b6 Tock ( The Open Conversation Kit ) est une boite \u00e0 outils permettant de construire des agents conversationnels (ou bots). Contrairement \u00e0 la plupart des autres solutions, il ne d\u00e9pend pas d\u2019API tierces (mais peut en int\u00e9grer ais\u00e9ment si n\u00e9cessaire) : il est donc possible de conserver le contr\u00f4le complet de ses donn\u00e9es et de ses algorithmes. Le code source de l'ensemble se trouve sur github : https://github.com/voyages-sncf-technologies/tock sous la licence Apache 2 . Deux composants majeurs sont disponibles, le moteur NLP ( pour Natural Language Processing ou TALN en fran\u00e7ais), et un framework conversationnel qui int\u00e8gre les services NLP et diff\u00e9rents connecteurs comme Messenger, Google Assistant ou Slack. La composante NLP est ind\u00e9pendante de la partie conversationnelle. Il est donc possible d'utiliser le NLP sans devoir ma\u00eetriser la complexit\u00e9 induite par la gestion des conversations. Dans certain cas d'usage importants, comme l' Internet des objets , l'utilisation d'un mod\u00e8le NLP seule est pertinente. Une plateforme pour construire des mod\u00e8les d'analyse du language naturel \u00b6 Interface d'administration \u00b6 L'outil principal est constitu\u00e9 par une interface d'administration qui permet de qualifier des phrases afin de construire des mod\u00e8les de traitement automatique du langage naturel ( TALN ) : Suivi de qualit\u00e9 des mod\u00e8les \u00b6 Cette interface fournit \u00e9galement les outils pour faire \u00e9voluer les mod\u00e8les et permet de monitorer leurs pertinences : Stanford CoreNLP ou Apache OpenNLP \u00b6 La construction automatique des mod\u00e8les est bas\u00e9e sur une de ces solutions open-sources (au choix). Tock fournit un niveau d'indirection qui permet d'int\u00e9grer d'autres librairies NLP. L'int\u00e9gration de SparkNLP est d'ailleurs en cours d'\u00e9tude. Duckling \u00b6 Un outil de parsing de dates et de types simples bas\u00e9 sur la librairie open-source Duckling est \u00e9galement int\u00e9gr\u00e9 par d\u00e9faut. API NLP \u00b6 Les mod\u00e8les peuvent \u00eatre utilis\u00e9s via l' API mis \u00e0 disposition. Un framework conversationnel \u00b6 Ce framework est la deuxi\u00e8me brique qui permet de construire des assistants. Elle utilise la brique de TALN de Tock via son API . Gestion du contexte et de l'historique \u00b6 La gestion des contextes des dialogues et de l\u2019historique des conversations est automatiquement disponible. Des notions avanc\u00e9es comme la fusion d'entit\u00e9s sont \u00e9galement mis \u00e0 disposition. (par exemple le fait de pr\u00e9ciser la date \"demain\" puis plus tard \"plut\u00f4t le soir\" met automatiquement la valeur de la date \u00e0 jour) Connecteurs tiers \u00b6 Des connecteurs \u00e0 Facebook Messenger, Google Assistant, WhatsApp, RocketChat, Twitter, Alexa, Teams et Slack sont disponibles. Il est possible d'en cr\u00e9er facilement d'autres, que ce soit pour se connecter \u00e0 d'autres canaux ou pour r\u00e9pondre \u00e0 des besoins sp\u00e9cifiques. Suivi des conversations \u00b6 Enfin une interface d'administration est mise \u00e0 disposition et permet de tester les bots et de suivre les conversations des utilisateurs. Gen\u00e8se du projet \u00b6 Le projet a \u00e9t\u00e9 initi\u00e9 en 2016 par l'\u00e9quipe Innovation de Oui.sncf dans un premier temps afin de motoriser l'analyse des commandes vocales sur ses applications mobiles . L'outil a ensuite \u00e9t\u00e9 utilis\u00e9 pour impl\u00e9menter son Bot Messenger . Depuis, une \u00e9quipe d\u00e9di\u00e9e au sein de OUI.sncf fait \u00e9voluer et maintient la solution. L' assistant Google OUI.sncf est \u00e9galement bas\u00e9 sur Tock, de m\u00eame que le OUIbot . Les outils ont \u00e9t\u00e9 open-sourc\u00e9s dans le but de mutualiser l'effort avec d'autres \u00e9quipes qui souhaiterait d\u00e9velopper des assistants ou bots. Technologies \u00b6 La plateforme applicative se base sur la JVM . Le langage de r\u00e9f\u00e9rence est Kotlin . Le reste de la panoplie applicative est constitu\u00e9e de Vert.x et MongoDB , m\u00eame si pour l\u2019instant les applications sont essentiellement d\u00e9velopp\u00e9s en \u00ab blocking IO \u00bb. En cible, l\u2019approche \u00ab fibers \u00bb ( cf http://docs.paralleluniverse.co/quasar/ ) sera privil\u00e9gi\u00e9e. Les interfaces d'administration sont impl\u00e9ment\u00e9es en Angular4 / Typescript . Cependant il est tout \u00e0 fait possible de d\u00e9velopper des applications en utilisant d'autres languages de programmation via les APIs mis \u00e0 disposition. Les diff\u00e9rents projets open-sourc\u00e9s \u00b6 Le projet principal se trouve sous licence Apache . Le code source est disponible sur GitHub : https://github.com/voyages-sncf-technologies/tock Cependant une d\u00e9pendance optionnelle, Stanford CoreNLP , est sous licence GPL . Le code utilisant cette d\u00e9pendance se trouve donc dans un projet \u00e0 part, sous licence GPL : https://github.com/voyages-sncf-technologies/tock-corenlp Enfin deux autres projets sont mis \u00e0 disposition : Un projet contenant des images dockers avec comme objectif de faciliter la prise en main : https://github.com/voyages-sncf-technologies/tock-docker Un projet contenant un exemple d'impl\u00e9mentation de bot se basant sur les API SNCF en Open Data : https://github.com/voyages-sncf-technologies/tock-bot-open-data Plateforme de d\u00e9monstration \u00b6 Une plateforme de d\u00e9monstration est disponible . Pour vous authentifier, un compte github est n\u00e9cessaire. Cette plateforme vous permet de d\u00e9couvrir les diff\u00e9rents aspects de Tock. Elle n'a pas vocation a \u00eatre utilis\u00e9e pour une application en production.","title":"Pr\u00e9sentation"},{"location":"#bienvenue-dans-la-documentation-de-tock","text":"","title":"Bienvenue dans la documentation de Tock!"},{"location":"#presentation","text":"Tock ( The Open Conversation Kit ) est une boite \u00e0 outils permettant de construire des agents conversationnels (ou bots). Contrairement \u00e0 la plupart des autres solutions, il ne d\u00e9pend pas d\u2019API tierces (mais peut en int\u00e9grer ais\u00e9ment si n\u00e9cessaire) : il est donc possible de conserver le contr\u00f4le complet de ses donn\u00e9es et de ses algorithmes. Le code source de l'ensemble se trouve sur github : https://github.com/voyages-sncf-technologies/tock sous la licence Apache 2 . Deux composants majeurs sont disponibles, le moteur NLP ( pour Natural Language Processing ou TALN en fran\u00e7ais), et un framework conversationnel qui int\u00e8gre les services NLP et diff\u00e9rents connecteurs comme Messenger, Google Assistant ou Slack. La composante NLP est ind\u00e9pendante de la partie conversationnelle. Il est donc possible d'utiliser le NLP sans devoir ma\u00eetriser la complexit\u00e9 induite par la gestion des conversations. Dans certain cas d'usage importants, comme l' Internet des objets , l'utilisation d'un mod\u00e8le NLP seule est pertinente.","title":"Pr\u00e9sentation"},{"location":"#une-plateforme-pour-construire-des-modeles-danalyse-du-language-naturel","text":"","title":"Une plateforme pour construire des mod\u00e8les d'analyse du language naturel"},{"location":"#interface-dadministration","text":"L'outil principal est constitu\u00e9 par une interface d'administration qui permet de qualifier des phrases afin de construire des mod\u00e8les de traitement automatique du langage naturel ( TALN ) :","title":"Interface d'administration"},{"location":"#suivi-de-qualite-des-modeles","text":"Cette interface fournit \u00e9galement les outils pour faire \u00e9voluer les mod\u00e8les et permet de monitorer leurs pertinences :","title":"Suivi de qualit\u00e9 des mod\u00e8les"},{"location":"#stanford-corenlp-ou-apache-opennlp","text":"La construction automatique des mod\u00e8les est bas\u00e9e sur une de ces solutions open-sources (au choix). Tock fournit un niveau d'indirection qui permet d'int\u00e9grer d'autres librairies NLP. L'int\u00e9gration de SparkNLP est d'ailleurs en cours d'\u00e9tude.","title":"Stanford CoreNLP ou Apache OpenNLP"},{"location":"#duckling","text":"Un outil de parsing de dates et de types simples bas\u00e9 sur la librairie open-source Duckling est \u00e9galement int\u00e9gr\u00e9 par d\u00e9faut.","title":"Duckling"},{"location":"#api-nlp","text":"Les mod\u00e8les peuvent \u00eatre utilis\u00e9s via l' API mis \u00e0 disposition.","title":"API NLP"},{"location":"#un-framework-conversationnel","text":"Ce framework est la deuxi\u00e8me brique qui permet de construire des assistants. Elle utilise la brique de TALN de Tock via son API .","title":"Un framework conversationnel"},{"location":"#gestion-du-contexte-et-de-lhistorique","text":"La gestion des contextes des dialogues et de l\u2019historique des conversations est automatiquement disponible. Des notions avanc\u00e9es comme la fusion d'entit\u00e9s sont \u00e9galement mis \u00e0 disposition. (par exemple le fait de pr\u00e9ciser la date \"demain\" puis plus tard \"plut\u00f4t le soir\" met automatiquement la valeur de la date \u00e0 jour)","title":"Gestion du contexte et de l'historique"},{"location":"#connecteurs-tiers","text":"Des connecteurs \u00e0 Facebook Messenger, Google Assistant, WhatsApp, RocketChat, Twitter, Alexa, Teams et Slack sont disponibles. Il est possible d'en cr\u00e9er facilement d'autres, que ce soit pour se connecter \u00e0 d'autres canaux ou pour r\u00e9pondre \u00e0 des besoins sp\u00e9cifiques.","title":"Connecteurs tiers"},{"location":"#suivi-des-conversations","text":"Enfin une interface d'administration est mise \u00e0 disposition et permet de tester les bots et de suivre les conversations des utilisateurs.","title":"Suivi des conversations"},{"location":"#genese-du-projet","text":"Le projet a \u00e9t\u00e9 initi\u00e9 en 2016 par l'\u00e9quipe Innovation de Oui.sncf dans un premier temps afin de motoriser l'analyse des commandes vocales sur ses applications mobiles . L'outil a ensuite \u00e9t\u00e9 utilis\u00e9 pour impl\u00e9menter son Bot Messenger . Depuis, une \u00e9quipe d\u00e9di\u00e9e au sein de OUI.sncf fait \u00e9voluer et maintient la solution. L' assistant Google OUI.sncf est \u00e9galement bas\u00e9 sur Tock, de m\u00eame que le OUIbot . Les outils ont \u00e9t\u00e9 open-sourc\u00e9s dans le but de mutualiser l'effort avec d'autres \u00e9quipes qui souhaiterait d\u00e9velopper des assistants ou bots.","title":"Gen\u00e8se du projet"},{"location":"#technologies","text":"La plateforme applicative se base sur la JVM . Le langage de r\u00e9f\u00e9rence est Kotlin . Le reste de la panoplie applicative est constitu\u00e9e de Vert.x et MongoDB , m\u00eame si pour l\u2019instant les applications sont essentiellement d\u00e9velopp\u00e9s en \u00ab blocking IO \u00bb. En cible, l\u2019approche \u00ab fibers \u00bb ( cf http://docs.paralleluniverse.co/quasar/ ) sera privil\u00e9gi\u00e9e. Les interfaces d'administration sont impl\u00e9ment\u00e9es en Angular4 / Typescript . Cependant il est tout \u00e0 fait possible de d\u00e9velopper des applications en utilisant d'autres languages de programmation via les APIs mis \u00e0 disposition.","title":"Technologies"},{"location":"#les-differents-projets-open-sources","text":"Le projet principal se trouve sous licence Apache . Le code source est disponible sur GitHub : https://github.com/voyages-sncf-technologies/tock Cependant une d\u00e9pendance optionnelle, Stanford CoreNLP , est sous licence GPL . Le code utilisant cette d\u00e9pendance se trouve donc dans un projet \u00e0 part, sous licence GPL : https://github.com/voyages-sncf-technologies/tock-corenlp Enfin deux autres projets sont mis \u00e0 disposition : Un projet contenant des images dockers avec comme objectif de faciliter la prise en main : https://github.com/voyages-sncf-technologies/tock-docker Un projet contenant un exemple d'impl\u00e9mentation de bot se basant sur les API SNCF en Open Data : https://github.com/voyages-sncf-technologies/tock-bot-open-data","title":"Les diff\u00e9rents projets open-sourc\u00e9s"},{"location":"#plateforme-de-demonstration","text":"Une plateforme de d\u00e9monstration est disponible . Pour vous authentifier, un compte github est n\u00e9cessaire. Cette plateforme vous permet de d\u00e9couvrir les diff\u00e9rents aspects de Tock. Elle n'a pas vocation a \u00eatre utilis\u00e9e pour une application en production.","title":"Plateforme de d\u00e9monstration"},{"location":"api/","text":"Une API permettant d'analyser une nouvelle phrase \u00e0 partir d'un mod\u00e8le NLU est disponible. Veuillez consulter sa documentation /api . Si vous souhaitez la tester en condition r\u00e9elle, elle est consultable \u00e0 partir des images docker \u00e0 l'adresse http://localhost/doc/index.html De m\u00eame, la documentation des APIs des interfaces d'administration est disponible /api/admin . Si vous souhaitez la tester en condition r\u00e9elle, elle est consultable \u00e0 partir des images docker \u00e0 l'adresse http://localhost/doc/admin.html Enfin il est possible d'utiliser l'API \"BOT\" pour d\u00e9velopper un bot sans adh\u00e9rence forte avec la stack Tock. (version b\u00e9ta)","title":"APIs de Tock"},{"location":"construire-le-modele/","text":"Mise en place d'un mod\u00e8le NLU (Natural Language Understanding) \u00b6 Vue d'ensemble \u00b6 Sept onglets sont disponibles : Try it : permet d'ajouter ou de tester l'analyse de nouvelles phrases Inbox : l'ensemble des phrases non encore qualifi\u00e9es Archive : l'ensembles des phrases archiv\u00e9es, c'est \u00e0 dire volontairement non encore reconnue par le mod\u00e8le Search : une interface de recherche avanc\u00e9e qui permet de rechercher les phrases enregistr\u00e9es, qu'elles soient ou non qualifi\u00e9es Intents : la liste des intentions du mod\u00e8le Entities : la liste des entit\u00e9s du mod\u00e8le Logs : La liste des requ\u00eates interrogeant le mod\u00e8le L'utilisateur est redirig\u00e9 par d\u00e9faut sur la cat\u00e9gorie Inbox . Ajouter et qualifier des phrases \u00b6 Pour ajouter une phrase \u00b6 Cliquez sur le menu Try It puis indiquez votre phrase. Il faut lui attribuer une intention en s\u00e9lectionnant \"Create a New Intent\" dans le liste de s\u00e9lection \"Intent\". Sp\u00e9cifier des entit\u00e9s \u00b6 Si n\u00e9cessaire, vous pouvez ensuite sp\u00e9cifier les entit\u00e9s que vous souhaitez que votre mod\u00e8le reconnaisse pour cette intention, en s\u00e9lectionnant les portions de phrases correspondantes \u00e0 ces entit\u00e9s, puis en cliquant sur le bouton \"Add New Entity\" qui vient d'appara\u00eetre A vous de choisir ensuite un type d'entit\u00e9 existant, ou d'en cr\u00e9er un nouveau, puis de donner un role \u00e0 cette entit\u00e9. Types d'entit\u00e9s pr\u00e9d\u00e9finies \u00b6 Dans cette fen\u00eatre de cr\u00e9ation d'entit\u00e9s, vous pouvez constater qu'il existe d\u00e9j\u00e0 un certain nombre d'entit\u00e9s (pr\u00e9fix\u00e9es par duckling: ). Il s'agit d'entit\u00e9s reconnues par la librairie \u00e9ponyme. Elle seront automatiquement reconnues et valoris\u00e9es pour cette intention si vous les sp\u00e9cifiez dans au moins une phrase de cette intention. Sp\u00e9cifier plusieurs entit\u00e9s \u00b6 Il est bien s\u00fbr possible d'avoir plusieurs occurrences du m\u00eame role, ou d'un r\u00f4le diff\u00e9rent dans la m\u00eame phrase. Valider la phrase \u00b6 Terminez la qualification de la phrase en cliquant sur le bouton \"Validate\". Au bout de 2 phrases qualifi\u00e9es pour une intention donn\u00e9e, il est possible que le 3\u00e8me phrase ajout\u00e9e soit imm\u00e9diatement reconnue. Si elle est qualifi\u00e9e correctement, vous n'avez plus qu'\u00e0 cliquer sur \"Validate\" pour confirmer que la phrase est correcte. Si ce n'est pas le cas, \u00e0 vous d'en corriger le sens avant de la valider. Vous \u00eates en train de construire votre premier mod\u00e8le ! Recherche de phrases \u00b6 L'onglet de recherche \u00b6 L'onglet Search permet de parcourir l'ensemble des phrases du mod\u00e8le en utilisant un certain nombre de crit\u00e8res. Le plus utilis\u00e9 est la recherche texte simple pour lequel il est \u00e9galement possible d'utiliser des expressions r\u00e9guli\u00e8res. Cela permet de consulter les phrases faisant partie de votre mod\u00e8le, et vous donne la possibilit\u00e9 de faire \u00e9voluer les qualifications de ces phrases au cours du temps. Les diff\u00e9rents \u00e9tats d'une phrase \u00b6 Chaque phrase \u00e0 un \u00e9tat (\"Status\") qui peut \u00e9voluer au cours du temps. Inbox : La phrase n'a pas encore \u00e9t\u00e9 qualifi\u00e9e et ne fait pas partie du mod\u00e8le Validated : La phrase a \u00e9t\u00e9 valid\u00e9e mais n'est pas encore pris en compte dans les mod\u00e8les de NLP (cela peut prendre du temps dans le cas de mod\u00e8les de taille importante) Included in model : La phrase a \u00e9t\u00e9 valid\u00e9e et a \u00e9t\u00e9 prise en compte dans les mod\u00e8les de NLP Caract\u00e9ristiques avanc\u00e9es \u00b6 En cliquant sur le menu \"Applications\", vous acc\u00e9dez \u00e0 la liste des applications disponibles. En cliquant sur le bouton de modification, plusieurs options sont disponibles. S\u00e9lection du moteur NLP \u00b6 Vous avez la possibilit\u00e9 de s\u00e9lectionner la librairie NLP utilis\u00e9e par cette application \u00e0 l'aide du bouton radio \"NLP engine\". Utilisation des mod\u00e8les d'entit\u00e9s \u00b6 Cette option permet de r\u00e9utiliser des mod\u00e8les d'entit\u00e9s pr\u00e9-construits dans vos nouvelles intentions. Par exemple, si vous cr\u00e9ez une intention avec une entit\u00e9 duckling:datetime , les dates seront automatiquement reconnues pour cette intention dans tous les nouvelles phrases attribu\u00e9es \u00e0 cette intention (En interne un arbitrage est effectu\u00e9 entre les informations provenant des mod\u00e8les d'entit\u00e9s pr\u00e9-construits et les informations tir\u00e9es de votre propre mod\u00e8le). Cette option est activ\u00e9e par d\u00e9faut, il peut \u00eatre utile de la d\u00e9sactiver pour les mod\u00e8les de taille tr\u00e8s importante, pour lesquels la d\u00e9tection native sera sup\u00e9rieure dans quasiment tous les cas \u00e0 celle des mod\u00e8les d'entit\u00e9s. Utiliser les sous-entit\u00e9s \u00b6 Si vous activez cette option, vous allez \u00eatre en mesure de qualifier plusieurs niveaux d'entit\u00e9s : Le nombre de niveaux n'est pas limit\u00e9, mais il est conseill\u00e9 de ne pas en sp\u00e9cifier plus de 3 ou 4. Utiliser les valeurs pr\u00e9definies \u00b6 Une entit\u00e9 donn\u00e9e peut avoir des valeurs pr\u00e9d\u00e9finies : pour cela vous devez aller dans l'onglet \"Entities\", selectionner une entit\u00e9 appartenant \u00e0 l'organization courante. Une petite ic\u00f4ne a cot\u00e9 de l'ic\u00f4ne de suppression montre les types d'entit\u00e9s que vous pourrez modifier comme le montre l'image ci-dessous. Dans l'exemple ci-dessus nous avons deux labels d\u00e9finis pour la valeur de semaine : \"Semaine\" et \"hebdomadaire\".","title":"Construire le mod\u00e8le"},{"location":"construire-le-modele/#mise-en-place-dun-modele-nlu-natural-language-understanding","text":"","title":"Mise en place d'un mod\u00e8le NLU (Natural Language Understanding)"},{"location":"construire-le-modele/#vue-densemble","text":"Sept onglets sont disponibles : Try it : permet d'ajouter ou de tester l'analyse de nouvelles phrases Inbox : l'ensemble des phrases non encore qualifi\u00e9es Archive : l'ensembles des phrases archiv\u00e9es, c'est \u00e0 dire volontairement non encore reconnue par le mod\u00e8le Search : une interface de recherche avanc\u00e9e qui permet de rechercher les phrases enregistr\u00e9es, qu'elles soient ou non qualifi\u00e9es Intents : la liste des intentions du mod\u00e8le Entities : la liste des entit\u00e9s du mod\u00e8le Logs : La liste des requ\u00eates interrogeant le mod\u00e8le L'utilisateur est redirig\u00e9 par d\u00e9faut sur la cat\u00e9gorie Inbox .","title":"Vue d'ensemble"},{"location":"construire-le-modele/#ajouter-et-qualifier-des-phrases","text":"","title":"Ajouter et qualifier des phrases"},{"location":"construire-le-modele/#pour-ajouter-une-phrase","text":"Cliquez sur le menu Try It puis indiquez votre phrase. Il faut lui attribuer une intention en s\u00e9lectionnant \"Create a New Intent\" dans le liste de s\u00e9lection \"Intent\".","title":"Pour ajouter une phrase"},{"location":"construire-le-modele/#specifier-des-entites","text":"Si n\u00e9cessaire, vous pouvez ensuite sp\u00e9cifier les entit\u00e9s que vous souhaitez que votre mod\u00e8le reconnaisse pour cette intention, en s\u00e9lectionnant les portions de phrases correspondantes \u00e0 ces entit\u00e9s, puis en cliquant sur le bouton \"Add New Entity\" qui vient d'appara\u00eetre A vous de choisir ensuite un type d'entit\u00e9 existant, ou d'en cr\u00e9er un nouveau, puis de donner un role \u00e0 cette entit\u00e9.","title":"Sp\u00e9cifier des entit\u00e9s"},{"location":"construire-le-modele/#types-dentites-predefinies","text":"Dans cette fen\u00eatre de cr\u00e9ation d'entit\u00e9s, vous pouvez constater qu'il existe d\u00e9j\u00e0 un certain nombre d'entit\u00e9s (pr\u00e9fix\u00e9es par duckling: ). Il s'agit d'entit\u00e9s reconnues par la librairie \u00e9ponyme. Elle seront automatiquement reconnues et valoris\u00e9es pour cette intention si vous les sp\u00e9cifiez dans au moins une phrase de cette intention.","title":"Types d'entit\u00e9s pr\u00e9d\u00e9finies"},{"location":"construire-le-modele/#specifier-plusieurs-entites","text":"Il est bien s\u00fbr possible d'avoir plusieurs occurrences du m\u00eame role, ou d'un r\u00f4le diff\u00e9rent dans la m\u00eame phrase.","title":"Sp\u00e9cifier plusieurs entit\u00e9s"},{"location":"construire-le-modele/#valider-la-phrase","text":"Terminez la qualification de la phrase en cliquant sur le bouton \"Validate\". Au bout de 2 phrases qualifi\u00e9es pour une intention donn\u00e9e, il est possible que le 3\u00e8me phrase ajout\u00e9e soit imm\u00e9diatement reconnue. Si elle est qualifi\u00e9e correctement, vous n'avez plus qu'\u00e0 cliquer sur \"Validate\" pour confirmer que la phrase est correcte. Si ce n'est pas le cas, \u00e0 vous d'en corriger le sens avant de la valider. Vous \u00eates en train de construire votre premier mod\u00e8le !","title":"Valider la phrase"},{"location":"construire-le-modele/#recherche-de-phrases","text":"","title":"Recherche de phrases"},{"location":"construire-le-modele/#longlet-de-recherche","text":"L'onglet Search permet de parcourir l'ensemble des phrases du mod\u00e8le en utilisant un certain nombre de crit\u00e8res. Le plus utilis\u00e9 est la recherche texte simple pour lequel il est \u00e9galement possible d'utiliser des expressions r\u00e9guli\u00e8res. Cela permet de consulter les phrases faisant partie de votre mod\u00e8le, et vous donne la possibilit\u00e9 de faire \u00e9voluer les qualifications de ces phrases au cours du temps.","title":"L'onglet de recherche"},{"location":"construire-le-modele/#les-differents-etats-dune-phrase","text":"Chaque phrase \u00e0 un \u00e9tat (\"Status\") qui peut \u00e9voluer au cours du temps. Inbox : La phrase n'a pas encore \u00e9t\u00e9 qualifi\u00e9e et ne fait pas partie du mod\u00e8le Validated : La phrase a \u00e9t\u00e9 valid\u00e9e mais n'est pas encore pris en compte dans les mod\u00e8les de NLP (cela peut prendre du temps dans le cas de mod\u00e8les de taille importante) Included in model : La phrase a \u00e9t\u00e9 valid\u00e9e et a \u00e9t\u00e9 prise en compte dans les mod\u00e8les de NLP","title":"Les diff\u00e9rents \u00e9tats d'une phrase"},{"location":"construire-le-modele/#caracteristiques-avancees","text":"En cliquant sur le menu \"Applications\", vous acc\u00e9dez \u00e0 la liste des applications disponibles. En cliquant sur le bouton de modification, plusieurs options sont disponibles.","title":"Caract\u00e9ristiques avanc\u00e9es"},{"location":"construire-le-modele/#selection-du-moteur-nlp","text":"Vous avez la possibilit\u00e9 de s\u00e9lectionner la librairie NLP utilis\u00e9e par cette application \u00e0 l'aide du bouton radio \"NLP engine\".","title":"S\u00e9lection du moteur NLP"},{"location":"construire-le-modele/#utilisation-des-modeles-dentites","text":"Cette option permet de r\u00e9utiliser des mod\u00e8les d'entit\u00e9s pr\u00e9-construits dans vos nouvelles intentions. Par exemple, si vous cr\u00e9ez une intention avec une entit\u00e9 duckling:datetime , les dates seront automatiquement reconnues pour cette intention dans tous les nouvelles phrases attribu\u00e9es \u00e0 cette intention (En interne un arbitrage est effectu\u00e9 entre les informations provenant des mod\u00e8les d'entit\u00e9s pr\u00e9-construits et les informations tir\u00e9es de votre propre mod\u00e8le). Cette option est activ\u00e9e par d\u00e9faut, il peut \u00eatre utile de la d\u00e9sactiver pour les mod\u00e8les de taille tr\u00e8s importante, pour lesquels la d\u00e9tection native sera sup\u00e9rieure dans quasiment tous les cas \u00e0 celle des mod\u00e8les d'entit\u00e9s.","title":"Utilisation des mod\u00e8les d'entit\u00e9s"},{"location":"construire-le-modele/#utiliser-les-sous-entites","text":"Si vous activez cette option, vous allez \u00eatre en mesure de qualifier plusieurs niveaux d'entit\u00e9s : Le nombre de niveaux n'est pas limit\u00e9, mais il est conseill\u00e9 de ne pas en sp\u00e9cifier plus de 3 ou 4.","title":"Utiliser les sous-entit\u00e9s"},{"location":"construire-le-modele/#utiliser-les-valeurs-predefinies","text":"Une entit\u00e9 donn\u00e9e peut avoir des valeurs pr\u00e9d\u00e9finies : pour cela vous devez aller dans l'onglet \"Entities\", selectionner une entit\u00e9 appartenant \u00e0 l'organization courante. Une petite ic\u00f4ne a cot\u00e9 de l'ic\u00f4ne de suppression montre les types d'entit\u00e9s que vous pourrez modifier comme le montre l'image ci-dessous. Dans l'exemple ci-dessus nous avons deux labels d\u00e9finis pour la valeur de semaine : \"Semaine\" et \"hebdomadaire\".","title":"Utiliser les valeurs pr\u00e9definies"},{"location":"contribuer/","text":"Contribuer au projet tock \u00b6 Construire le projet \u00b6 Le projet utilise Maven . mvn package Un build d'int\u00e9gration continue est disponible sur Travis . Lancer le projet dans l'IDE \u00b6 Outre les images docker , des configurations IntelliJ sont disponibles : Le serveur d'administration du bot : BotAdmin Le serveur d'administration du NLP uniquement : Admin Le service NLP : NlpService Le service Duckling : Duckling Le service de construction des mod\u00e8les NLP : BuildWorker Le service de compilation des scripts : KotlinCompilerServer Pour le bot d'exemple : OpenDataBot Enfin pour lancer les interfaces d'administration, vous aurez besoin de lancer les commandes d\u00e9crites dans les liens suivants : Pour l'administration compl\u00e8te (Bot + NLP) Pour l'administration NLP uniquement Code conventions \u00b6 Le format \u00e0 suivre est d\u00e9crit dans les Kotlin Code Conventions","title":"Contribuer au projet"},{"location":"contribuer/#contribuer-au-projet-tock","text":"","title":"Contribuer au projet tock"},{"location":"contribuer/#construire-le-projet","text":"Le projet utilise Maven . mvn package Un build d'int\u00e9gration continue est disponible sur Travis .","title":"Construire le projet"},{"location":"contribuer/#lancer-le-projet-dans-lide","text":"Outre les images docker , des configurations IntelliJ sont disponibles : Le serveur d'administration du bot : BotAdmin Le serveur d'administration du NLP uniquement : Admin Le service NLP : NlpService Le service Duckling : Duckling Le service de construction des mod\u00e8les NLP : BuildWorker Le service de compilation des scripts : KotlinCompilerServer Pour le bot d'exemple : OpenDataBot Enfin pour lancer les interfaces d'administration, vous aurez besoin de lancer les commandes d\u00e9crites dans les liens suivants : Pour l'administration compl\u00e8te (Bot + NLP) Pour l'administration NLP uniquement","title":"Lancer le projet  dans l'IDE"},{"location":"contribuer/#code-conventions","text":"Le format \u00e0 suivre est d\u00e9crit dans les Kotlin Code Conventions","title":"Code conventions"},{"location":"developper-api/","text":"D\u00e9velopper un Assistant via API (b\u00e9ta) \u00b6 Une API est mise \u00e0 disposition pour d\u00e9velopper un Assistant. Les fonctionnalit\u00e9s sont aujourd'hui limit\u00e9es par rapport au mode \"Assistant Tock\" mais ont vocation \u00e0 \u00eatre \u00e9tendues rapidement. Il est possible d'utiliser cette API de deux mani\u00e8res : En utilisant le client Kotlin mis \u00e0 disposition En se connectant \u00e0 l'API dans un autre langage Client Kotlin \u00b6 Websocket \u00b6 La version \u00e0 privil\u00e9gier au d\u00e9marrage est la version utilisant les websockets. Pour utiliser le client websocket, il faut ajouter la d\u00e9pendance tock-bot-api-websocket \u00e0 votre projet. Avec Maven : <dependency> <groupId> fr.vsct.tock </groupId> <artifactId> tock-bot-api-websocket </artifactId> <version> 19.3.2 </version> </dependency> ou Gradle : compile 'fr.vsct.tock:tock-bot-api-websocket:19.3.2' Webhook \u00b6 Pour utiliser le client webhook, il faut ajouter la d\u00e9pendance tock-bot-api-webhook \u00e0 votre projet. Avec Maven : <dependency> <groupId> fr.vsct.tock </groupId> <artifactId> tock-bot-api-webhook </artifactId> <version> 19.3.2 </version> </dependency> ou Gradle : compile 'fr.vsct.tock:tock-bot-api-webhook:19.3.2' Dans ce cas, contrairement au mode \"websocket\", il faut bien s\u00fbr que l'url du serveur d\u00e9marr\u00e9 soit joignable par la stack docker Tock. Cette url doit \u00eatre indiqu\u00e9e dans le champ \"webhook url\" de la configuration choisie dans l'onglet Configuration -> Bots Configurations. R\u00e9cup\u00e9ration de la cl\u00e9 de l'API \u00b6 Aller dans Configuration -> Bot Configurations et copiez/collez la cl\u00e9 de l'api correspondant \u00e0 la configuration sur laquelle vous souhaitez vous connecter. Premi\u00e8re version de l'Assistant \u00b6 Le toolkit mis \u00e0 disposition supporte dans ses r\u00e9ponses le format text simple, le format \"carte\" et tous les formats sp\u00e9cifiques aux diff\u00e9rents canaux support\u00e9s. Voici un exemple de Bot simple : fun main () { start ( newBot ( //cl\u00e9 de l'API \"4149823a-ac28-4a5d-9f3c-0e8f48a11865\" , //r\u00e9ponse simple ,correspondant \u00e0 l'intention greetings newStory ( \"greetings\" ) { end ( \"Coucou\" ) }, //r\u00e9ponse sous format card correspondant \u00e0 l'intention location newStory ( \"location\" ) { end ( newCard ( \"Titre\" , \"Sous-Titre\" , newAttachment ( \"https://url-image.png\" ), newAction ( \"Action 1\" ), newAction ( \"Action 2\" , \"http://redirection\" ) ) ) } //r\u00e9ponse sous format sp\u00e9cifique au canal (ici messenger) //correspondant \u00e0 l'intention goodbye newStory ( \"goodbye\" ) { end { buttonsTemplate ( \"Mais pourquoi?\" , nlpQuickReply ( \"Je ne veux pas partir\" )) } } //r\u00e9ponse renvoy\u00e9e quand l'intention n'est pas r\u00e9pertori\u00e9e unknownStory { end ( \"je n'ai pas compris\" ) } )) } Se connecter \u00e0 la plateforme de d\u00e9monstration \u00b6 Pour se connecter automatiquement \u00e0 la plateforme de d\u00e9monstration, utilisez la m\u00e9thode startWithDemo() au lieu de `start()`` Se connecter \u00e0 l'API directement \u00b6 Contrat API en cours de r\u00e9daction","title":"D\u00e9velopper via API"},{"location":"developper-api/#developper-un-assistant-via-api-beta","text":"Une API est mise \u00e0 disposition pour d\u00e9velopper un Assistant. Les fonctionnalit\u00e9s sont aujourd'hui limit\u00e9es par rapport au mode \"Assistant Tock\" mais ont vocation \u00e0 \u00eatre \u00e9tendues rapidement. Il est possible d'utiliser cette API de deux mani\u00e8res : En utilisant le client Kotlin mis \u00e0 disposition En se connectant \u00e0 l'API dans un autre langage","title":"D\u00e9velopper un Assistant via API (b\u00e9ta)"},{"location":"developper-api/#client-kotlin","text":"","title":"Client Kotlin"},{"location":"developper-api/#websocket","text":"La version \u00e0 privil\u00e9gier au d\u00e9marrage est la version utilisant les websockets. Pour utiliser le client websocket, il faut ajouter la d\u00e9pendance tock-bot-api-websocket \u00e0 votre projet. Avec Maven : <dependency> <groupId> fr.vsct.tock </groupId> <artifactId> tock-bot-api-websocket </artifactId> <version> 19.3.2 </version> </dependency> ou Gradle : compile 'fr.vsct.tock:tock-bot-api-websocket:19.3.2'","title":"Websocket"},{"location":"developper-api/#webhook","text":"Pour utiliser le client webhook, il faut ajouter la d\u00e9pendance tock-bot-api-webhook \u00e0 votre projet. Avec Maven : <dependency> <groupId> fr.vsct.tock </groupId> <artifactId> tock-bot-api-webhook </artifactId> <version> 19.3.2 </version> </dependency> ou Gradle : compile 'fr.vsct.tock:tock-bot-api-webhook:19.3.2' Dans ce cas, contrairement au mode \"websocket\", il faut bien s\u00fbr que l'url du serveur d\u00e9marr\u00e9 soit joignable par la stack docker Tock. Cette url doit \u00eatre indiqu\u00e9e dans le champ \"webhook url\" de la configuration choisie dans l'onglet Configuration -> Bots Configurations.","title":"Webhook"},{"location":"developper-api/#recuperation-de-la-cle-de-lapi","text":"Aller dans Configuration -> Bot Configurations et copiez/collez la cl\u00e9 de l'api correspondant \u00e0 la configuration sur laquelle vous souhaitez vous connecter.","title":"R\u00e9cup\u00e9ration de la cl\u00e9 de l'API"},{"location":"developper-api/#premiere-version-de-lassistant","text":"Le toolkit mis \u00e0 disposition supporte dans ses r\u00e9ponses le format text simple, le format \"carte\" et tous les formats sp\u00e9cifiques aux diff\u00e9rents canaux support\u00e9s. Voici un exemple de Bot simple : fun main () { start ( newBot ( //cl\u00e9 de l'API \"4149823a-ac28-4a5d-9f3c-0e8f48a11865\" , //r\u00e9ponse simple ,correspondant \u00e0 l'intention greetings newStory ( \"greetings\" ) { end ( \"Coucou\" ) }, //r\u00e9ponse sous format card correspondant \u00e0 l'intention location newStory ( \"location\" ) { end ( newCard ( \"Titre\" , \"Sous-Titre\" , newAttachment ( \"https://url-image.png\" ), newAction ( \"Action 1\" ), newAction ( \"Action 2\" , \"http://redirection\" ) ) ) } //r\u00e9ponse sous format sp\u00e9cifique au canal (ici messenger) //correspondant \u00e0 l'intention goodbye newStory ( \"goodbye\" ) { end { buttonsTemplate ( \"Mais pourquoi?\" , nlpQuickReply ( \"Je ne veux pas partir\" )) } } //r\u00e9ponse renvoy\u00e9e quand l'intention n'est pas r\u00e9pertori\u00e9e unknownStory { end ( \"je n'ai pas compris\" ) } )) }","title":"Premi\u00e8re version de l'Assistant"},{"location":"developper-api/#se-connecter-a-la-plateforme-de-demonstration","text":"Pour se connecter automatiquement \u00e0 la plateforme de d\u00e9monstration, utilisez la m\u00e9thode startWithDemo() au lieu de `start()``","title":"Se connecter \u00e0 la plateforme de d\u00e9monstration"},{"location":"developper-api/#se-connecter-a-lapi-directement","text":"Contrat API en cours de r\u00e9daction","title":"Se connecter \u00e0 l'API directement"},{"location":"developper-un-assistant/","text":"Comment d\u00e9velopper un Assistant \u00b6 Ajouter une premi\u00e8re r\u00e9ponse - Le menu \"Build\"' \u00b6 Cr\u00e9er une Story via l'interface d'administration \u00b6 Dans le menu \"Build\" il est possible de cr\u00e9er une r\u00e9ponse \u00e0 une intention du mod\u00e8le. R\u00e9ponse simple \u00b6 Dans l'onglet \"New Story\", indiquez une phrase d'exemple, la r\u00e9ponse attendue, puis sur le bouton \"Create Story\". Il est maintenant possible de tester (via le menu \"Test\") que le bot r\u00e9pond correctement \u00e0 la phrase d'exemple. R\u00e9ponses Complexes \u00b6 Il est possible d'indiquer plusieurs r\u00e9ponses et \u00e9galement des r\u00e9ponses \"riches\" appel\u00e9es \"Media Message\". Cela permet, quel que soit le canal d'afficher des images, des titres, des sous-titres et des boutons d'action. Entit\u00e9s obligatoires \u00b6 Il est possible, avant d'afficher la r\u00e9ponse principale, de v\u00e9rifier si certaines entit\u00e9es sont renseign\u00e9es, et si ce n'est pas le cas, d'afficher la question ad\u00e9quate. L'option correspondante est appell\u00e9e \"Mandatory Entities\". Par exemple, supposons que nous ayons besoin de conna\u00eetre la destination de l'utilisateur. Si il ne l'a pas d\u00e9j\u00e0 indiqu\u00e9e, Nous allons lui poser la question \"Pour quelle destination ?\" Actions \u00b6 Les actions sont pr\u00e9sent\u00e9es comme des suggestions quand le canal le permet. Il est possible de pr\u00e9senter une arborescence d'actions pour construire un arbre de d\u00e9cision. Bot Flow \u00b6 Cet onglet permet de visualiser les diff\u00e9rents arbres de d\u00e9cisions configur\u00e9s, et \u00e9galement de visualiser tout ce qui a \u00e9t\u00e9 r\u00e9ellement effectu\u00e9 par les utilisateurs. Modification des r\u00e9ponses et internationalisation \u00b6 Enfin il est possible de modifier chaque r\u00e9ponse du bot par type d'interface (chat/voix), par type de connecteur et par langue via l'onglet i18n . Il est aussi possible de rajouter des r\u00e9ponses alternatives ( \u00e0 chaque fois une r\u00e9ponse de la liste sera choisie au hasard) via cette interface. Le menu Test \u00b6 Via ce menu, vous pouvez commencer \u00e0 tester le bot : L'interface est minimale car il s'agit d'un mode de test. L'objectif reste de faire dialoguer vos utilisateurs avec le bot via des canaux comme Messenger, Google Assistant... ou vos sites ou applications. Le menu Monitoring \u00b6 Il est ensuite possible de consulter la discussion que vous venez d'avoir avec le bot via l'onglet Monitoring Ici, le canal est indiqu\u00e9 comme \u00e9tant celui de Messenger puisque il a \u00e9t\u00e9 simul\u00e9 une conversation Messenger. Deux possibilit\u00e9s de d\u00e9veloppement \u00b6 Pour aller plus loin dans le d\u00e9veloppement d'un assistant, il va n\u00e9cessaire d'utiliser des scripts ou du code. Assistant Tock \u00b6 Dans ce mode, vous acc\u00e8s \u00e0 l'int\u00e9gralit\u00e9 des fonctionnalit\u00e9s que met \u00e0 disposition Tock pour d\u00e9velopper un Bot. C'est de cette mani\u00e8re que sont d\u00e9velopp\u00e9s aujourd'hui les bots publi\u00e9s par les concepteurs de Tock. Cependant la phase de mise en place de la solution est assez complexe. Il est en effet n\u00e9cessaire : D'installer une stack docker sur son poste ou sur son serveur De permettre la connexion partag\u00e9e \u00e0 la base MongoDB entre les poste de dev et la stack Tock utilis\u00e9e De ma\u00eetriser le langage Kotlin Assistant via API \u00b6 Si vous souhaitez \u00e9valuer la solution Tock, il est conseill\u00e9 d'utiliser les APIs (actuellement en phase b\u00e9ta) mises \u00e0 disposition par Tock. Deux options s'offrent \u00e0 vous. Installer Tock sur votre serveur \u00b6 Vous installez la stack docker de Tock sur votre serveur. Vous conservez ainsi l'ensemble de vos donn\u00e9es. Vos d\u00e9veloppeurs utilisent l'API pour se connecter \u00e0 Tock. Ils n'ont donc pas besoin d'avoir acc\u00e8s \u00e0 la base de donn\u00e9es de Tock. Utiliser la plateforme de d\u00e9monstration \u00b6 Vous pouvez \u00e9galement utiliser la plateforme de d\u00e9monstration mutualis\u00e9e de Tock . Dans ce cas, il n'est pas n\u00e9cessaire d'installer Tock sur vos serveurs. A noter cependant que cet usage convient pour un environnement de d\u00e9veloppement et en aucun cas pour un environnement de production.","title":"D\u00e9velopper un Assistant"},{"location":"developper-un-assistant/#comment-developper-un-assistant","text":"","title":"Comment d\u00e9velopper un Assistant"},{"location":"developper-un-assistant/#ajouter-une-premiere-reponse-le-menu-build","text":"","title":"Ajouter une premi\u00e8re r\u00e9ponse - Le menu \"Build\"'"},{"location":"developper-un-assistant/#creer-une-story-via-linterface-dadministration","text":"Dans le menu \"Build\" il est possible de cr\u00e9er une r\u00e9ponse \u00e0 une intention du mod\u00e8le.","title":"Cr\u00e9er une Story via l'interface d'administration"},{"location":"developper-un-assistant/#reponse-simple","text":"Dans l'onglet \"New Story\", indiquez une phrase d'exemple, la r\u00e9ponse attendue, puis sur le bouton \"Create Story\". Il est maintenant possible de tester (via le menu \"Test\") que le bot r\u00e9pond correctement \u00e0 la phrase d'exemple.","title":"R\u00e9ponse simple"},{"location":"developper-un-assistant/#reponses-complexes","text":"Il est possible d'indiquer plusieurs r\u00e9ponses et \u00e9galement des r\u00e9ponses \"riches\" appel\u00e9es \"Media Message\". Cela permet, quel que soit le canal d'afficher des images, des titres, des sous-titres et des boutons d'action.","title":"R\u00e9ponses Complexes"},{"location":"developper-un-assistant/#entites-obligatoires","text":"Il est possible, avant d'afficher la r\u00e9ponse principale, de v\u00e9rifier si certaines entit\u00e9es sont renseign\u00e9es, et si ce n'est pas le cas, d'afficher la question ad\u00e9quate. L'option correspondante est appell\u00e9e \"Mandatory Entities\". Par exemple, supposons que nous ayons besoin de conna\u00eetre la destination de l'utilisateur. Si il ne l'a pas d\u00e9j\u00e0 indiqu\u00e9e, Nous allons lui poser la question \"Pour quelle destination ?\"","title":"Entit\u00e9s obligatoires"},{"location":"developper-un-assistant/#actions","text":"Les actions sont pr\u00e9sent\u00e9es comme des suggestions quand le canal le permet. Il est possible de pr\u00e9senter une arborescence d'actions pour construire un arbre de d\u00e9cision.","title":"Actions"},{"location":"developper-un-assistant/#bot-flow","text":"Cet onglet permet de visualiser les diff\u00e9rents arbres de d\u00e9cisions configur\u00e9s, et \u00e9galement de visualiser tout ce qui a \u00e9t\u00e9 r\u00e9ellement effectu\u00e9 par les utilisateurs.","title":"Bot Flow"},{"location":"developper-un-assistant/#modification-des-reponses-et-internationalisation","text":"Enfin il est possible de modifier chaque r\u00e9ponse du bot par type d'interface (chat/voix), par type de connecteur et par langue via l'onglet i18n . Il est aussi possible de rajouter des r\u00e9ponses alternatives ( \u00e0 chaque fois une r\u00e9ponse de la liste sera choisie au hasard) via cette interface.","title":"Modification des r\u00e9ponses et internationalisation"},{"location":"developper-un-assistant/#le-menu-test","text":"Via ce menu, vous pouvez commencer \u00e0 tester le bot : L'interface est minimale car il s'agit d'un mode de test. L'objectif reste de faire dialoguer vos utilisateurs avec le bot via des canaux comme Messenger, Google Assistant... ou vos sites ou applications.","title":"Le menu Test"},{"location":"developper-un-assistant/#le-menu-monitoring","text":"Il est ensuite possible de consulter la discussion que vous venez d'avoir avec le bot via l'onglet Monitoring Ici, le canal est indiqu\u00e9 comme \u00e9tant celui de Messenger puisque il a \u00e9t\u00e9 simul\u00e9 une conversation Messenger.","title":"Le menu Monitoring"},{"location":"developper-un-assistant/#deux-possibilites-de-developpement","text":"Pour aller plus loin dans le d\u00e9veloppement d'un assistant, il va n\u00e9cessaire d'utiliser des scripts ou du code.","title":"Deux possibilit\u00e9s de d\u00e9veloppement"},{"location":"developper-un-assistant/#assistant-tock","text":"Dans ce mode, vous acc\u00e8s \u00e0 l'int\u00e9gralit\u00e9 des fonctionnalit\u00e9s que met \u00e0 disposition Tock pour d\u00e9velopper un Bot. C'est de cette mani\u00e8re que sont d\u00e9velopp\u00e9s aujourd'hui les bots publi\u00e9s par les concepteurs de Tock. Cependant la phase de mise en place de la solution est assez complexe. Il est en effet n\u00e9cessaire : D'installer une stack docker sur son poste ou sur son serveur De permettre la connexion partag\u00e9e \u00e0 la base MongoDB entre les poste de dev et la stack Tock utilis\u00e9e De ma\u00eetriser le langage Kotlin","title":"Assistant Tock"},{"location":"developper-un-assistant/#assistant-via-api","text":"Si vous souhaitez \u00e9valuer la solution Tock, il est conseill\u00e9 d'utiliser les APIs (actuellement en phase b\u00e9ta) mises \u00e0 disposition par Tock. Deux options s'offrent \u00e0 vous.","title":"Assistant via API"},{"location":"developper-un-assistant/#installer-tock-sur-votre-serveur","text":"Vous installez la stack docker de Tock sur votre serveur. Vous conservez ainsi l'ensemble de vos donn\u00e9es. Vos d\u00e9veloppeurs utilisent l'API pour se connecter \u00e0 Tock. Ils n'ont donc pas besoin d'avoir acc\u00e8s \u00e0 la base de donn\u00e9es de Tock.","title":"Installer Tock sur votre serveur"},{"location":"developper-un-assistant/#utiliser-la-plateforme-de-demonstration","text":"Vous pouvez \u00e9galement utiliser la plateforme de d\u00e9monstration mutualis\u00e9e de Tock . Dans ce cas, il n'est pas n\u00e9cessaire d'installer Tock sur vos serveurs. A noter cependant que cet usage convient pour un environnement de d\u00e9veloppement et en aucun cas pour un environnement de production.","title":"Utiliser la plateforme de d\u00e9monstration"},{"location":"developper/","text":"Le langage d\u00e9di\u00e9 au conversationnel de Tock \u00b6 Pour d\u00e9velopper un bot ou un assistant avec Tock en mode int\u00e9gr\u00e9, il est n\u00e9cessaire aujourd'hui de d\u00e9velopper dans un Domain Specifique Language (DSL) d\u00e9velopp\u00e9 en Kotlin via un IDE. Dans ce mode de d\u00e9veloppement, il est n\u00e9cessaire de disposer d'une connexion \u00e0 la base de donn\u00e9e de Tock. Pour appr\u00e9hender compl\u00e8tement ce qui va suivre, il est recommand\u00e9 de ma\u00eetriser les bases du langage Kotlin. Ajouter la d\u00e9pendance bot-toolkit \u00b6 Pour utiliser le framework conversationnel, il faut ajouter la d\u00e9pendance bot-tookit \u00e0 votre projet. Avec Maven : <dependency> <groupId> fr.vsct.tock </groupId> <artifactId> bot-toolkit </artifactId> <version> 19.3.2 </version> </dependency> ou Gradle : compile 'fr.vsct.tock:bot-toolkit:19.3.2' Un bot est un ensemble de Stories \u00b6 Voici comment le bot open data est d\u00e9fini : val openBot = bot ( \"bot_open_data\" , stories = listOf ( greetings , departures , arrivals , search ), hello = greetings ) Ce bot comporte un identifiant (obligatoire - \"bot_open_data\") et une liste de \"Story\" . Une Story est un regroupement fonctionnel qui correspond \u00e0 une intention principale et, de mani\u00e8re optionelle, \u00e0 une ou plusieurs intentions dites \"secondaires\". Ici le bot d\u00e9finit 4 Stories , greetings, departures, arrivals et search. greetings est par ailleurs ( hello = greetings ) indiqu\u00e9e comme \u00e9tant la story pr\u00e9sent\u00e9e par d\u00e9faut lors du d\u00e9but d'une conversation. Une Story simple \u00b6 Comment d\u00e9finit-on une Story? Voici une premi\u00e8re version simplifi\u00e9e de la Story greetings : val greetings = story ( \"greetings\" ) { send ( \"Bienvenue chez le Bot Open Data Sncf! :)\" ) end ( \"Il s'agit d'un bot de d\u00e9monstration du framework Tock : https://github.com/voyages-sncf-technologies/tock\" ) } Notez que dans le corps de la fonction, this est de type BotBus , \u00e0 partir duquel vous pouvez interagir avec l'utilisateur, et qui permet \u00e9galement d'acc\u00e8der \u00e0 tous les \u00e9lements contextuels disponibles. Concr\u00e8tement sela signifie que quand l'intention greetings sera d\u00e9tect\u00e9e par le mod\u00e8le NLP, la fonction ci-dessus sera appel\u00e9e par le framework Tock. Le bot envoie donc successivement une premi\u00e8re phrase de r\u00e9ponse ( bus.send() ), puis un deuxi\u00e8me en indiquant que c'est la derni\u00e8re phrase de sa r\u00e9ponse \u00e0 l'aide d'un bus.end() . Voici maintenant la version compl\u00e8te de greetings : val greetings = story ( \"greetings\" ) { //cleanup state resetDialogState () send ( \"Bienvenue chez le Bot Open Data Sncf! :)\" ) send ( \"Il s'agit d'un bot de d\u00e9monstration du framework Tock : https://github.com/voyages-sncf-technologies/tock\" ) withMessenger { buttonsTemplate ( \"Il est volontairement tr\u00e8s limit\u00e9, mais demandez lui un itin\u00e9raire ou les d\u00e9parts \u00e0 partir d'une gare et constatez le r\u00e9sultat! :) \" , postbackButton ( \"Itin\u00e9raires\" , search ), postbackButton ( \"D\u00e9parts\" , Departures ), postbackButton ( \"Arriv\u00e9es\" , Arrivals ) ) } withGoogleAssistant { gaMessage ( \"Il est volontairement tr\u00e8s limit\u00e9, mais demandez lui un itin\u00e9raire ou les d\u00e9parts \u00e0 partir d'une gare et constatez le r\u00e9sultat! :) \" , \"Itin\u00e9raires\" , \"D\u00e9parts\" , \"Arriv\u00e9es\" ) } end () } Deux notions ont \u00e9t\u00e9 ajout\u00e9es : resetDialogState() qui permet de repartir d'un contexte utilisateur vide (en oubliant les \u00e9ventuels \u00e9changes pr\u00e9c\u00e9dents) les m\u00e9thodes withMessenger{} et withGoogleAssistant{} qui permettent de d\u00e9finir des r\u00e9ponses sp\u00e9cifiques pour chaque connecteur. Ici un texte avec des boutons pour Messenger, et un texte avec des suggestions pour Google Assistant. D\u00e9marrer et connecter le bot \u00b6 Pour d\u00e9marrer le bot, il suffit de rajouter dans votre main principal l'appel suivant: registerAndInstallBot ( openBot ) o\u00f9 la variable openBot est le bot que vous avez d\u00e9fini au d\u00e9part. Une fois le bot d\u00e9marr\u00e9, il est \u00e9galement n\u00e9cessaire de sp\u00e9cifier quels connecteurs sont utilis\u00e9s dans l'interface d'administration du bot, du menu Configuration -> Bot Configurations -> Create a new configuration. La documentation pour chaque connecteur se trouve dans le README des projects correspondants. Cinq par d\u00e9faut sont disponibles \u00e0 l'heure actuelle : Messenger Google Assistant Slack RocketChat Twitter WhatsApp Teams Alexa - A noter que dans le cas d'Alexa, le mod\u00e8le NLP est forc\u00e9ment chez Amazon. Seul le framework conversationel de Tock peut donc \u00eatre utilis\u00e9. Aller un peu plus loin \u00b6 Bien s\u00fbr, le Story Handler de greetings ne d\u00e9pend pas du contexte : la r\u00e9ponse est toujours la m\u00eame. Pour le d\u00e9veloppement de stories complexes, nous avons besoin d'une abstraction suppl\u00e9mentaire. Intentions secondaires \u00b6 Voici le d\u00e9but de la d\u00e9finition de la story search : val search = storyDef < SearchDef >( \"search\" , otherStarterIntents = setOf ( indicate_origin ), secondaryIntents = setOf ( indicate_location )) { } La story search d\u00e9finit une intention secondaire \"de d\u00e9marrage\" ( indicate_origin ) et une intention secondaire simple ( indicate_location ) Une intention secondaire \"de d\u00e9marrage\" est semblable en tout point \u00e0 une intention principale : d\u00e8s que cette intention est d\u00e9tect\u00e9e, la story search va \u00eatre ex\u00e9cut\u00e9e, si la story courante ne poss\u00e8de pas cette intention en tant qu'intention secondaire. Pour une intention secondaire simple, par contre, la story ne sera ex\u00e9cut\u00e9e que si la story courante du contexte est d\u00e9j\u00e0 la story search. Plusieurs story diff\u00e9rentes peuvent donc partager les m\u00eames intentions secondaires. Manipuler les entit\u00e9s \u00b6 Pour r\u00e9cup\u00e9rer les valeurs des entit\u00e9s, une bonne pratique est de d\u00e9finir des extensions . Par exemple voici le code utilis\u00e9 pour r\u00e9cup\u00e9rer l'entit\u00e9 destination : val destinationEntity = openBot . entity ( \"location\" , \"destination\" ) var BotBus . destination : Place ? get () = place ( destinationEntity ) set ( value ) = setPlace ( destinationEntity , value ) private fun BotBus . place ( entity : Entity ): Place ? = entityValue ( entity , :: placeValue ) ?. place private fun BotBus . setPlace ( entity : Entity , place : Place ?) = changeEntityValue ( entity , place ?. let { PlaceValue ( place ) }) Une entit\u00e9 de type \"location\" et de role \"destination\" est cr\u00e9\u00e9e. Il s'agit de l'entit\u00e9 correspondante dans le mod\u00e8le NLP. Une variable destination est d\u00e9finie, qui va simplifier la manipulation de cette entit\u00e9 dans le code m\u00e9tier. Cette variable contient la valeur actuelle de la destination dans le contexte utilisateur. Voici une version compl\u00e9t\u00e9e de la story search qui utilise destination : val search = storyDef < SearchDef >( \"search\" , setOf ( indicate_origin ), setOf ( indicate_location )) { //check mandatory entities when { destination == null -> end ( \"Pour quelle destination?\" ) origin == null -> end ( \"Pour quelle origine?\" ) departureDate == null -> end ( \"Quand souhaitez-vous partir?\" ) } } Si il n'y a pas de valeur dans le contexte courant pour la destination, le bot demande de sp\u00e9cifier la destination et en reste l\u00e0. Idem pour l'origine ou la date de d\u00e9part. Si les 3 valeurs obligatoires sont sp\u00e9cifi\u00e9es, il passe \u00e0 la r\u00e9ponse proprement dite d\u00e9velopp\u00e9e dans la classe ( SearchDef ). La version compl\u00e8te de cette premi\u00e8re partie du code est la suivante : val search = storyDef < SearchDef >( \"search\" , setOf ( indicate_origin ), setOf ( indicate_location )) { //handle generic location intent if ( isIntent ( indicate_location ) && location != null ) { if ( destination == null || origin != null ) { destination = returnsAndRemoveLocation () } else { origin = returnsAndRemoveLocation () } } //check mandatory entities when { destination == null -> end ( \"Pour quelle destination?\" ) origin == null -> end ( \"Pour quelle origine?\" ) departureDate == null -> end ( \"Quand souhaitez-vous partir?\" ) } } Dans le cas o\u00f9 l'intention d\u00e9tect\u00e9e est indicate_location , nous ne savons pas si la localit\u00e9 indiqu\u00e9e repr\u00e9sente l'origine ou la destination. Il est donc cod\u00e9 une r\u00e8gle simple : Si il existe d\u00e9j\u00e0 dans le contexte une origine et pas de destination, la nouvelle localit\u00e9 est en fait la destination. Sinon, il s'agit de l'origine. Utiliser HandlerDef \u00b6 Dans la d\u00e9finition de la story search ci-dessus, vous avez pu noter le typage g\u00e9n\u00e9rique SearchDef . Voici le code de cette classe : @GAHandler ( GASearchConnector :: class ) @MessengerHandler ( MessengerSearchConnector :: class ) class SearchDef ( bus : BotBus ) : HandlerDef < SearchConnector >( bus ) { private val d : Place = bus . destination !! private val o : Place = bus . origin !! private val date : LocalDateTime = bus . departureDate !! override fun answer () { send ( \"De {0} \u00e0 {1}\" , o , d ) send ( \"D\u00e9part le {0}\" , date by datetimeFormat ) val journeys = SncfOpenDataClient . journey ( o , d , date ) if ( journeys . isEmpty ()) { end ( \"D\u00e9sol\u00e9, aucun itin\u00e9raire trouv\u00e9 :(\" ) } else { send ( \"Voici la premi\u00e8re proposition :\" ) connector ?. sendFirstJourney ( journeys . first ()) end () } } } SearchDef \u00e9tend HandlerDef qui est un alias d'une classe du framework Tock. C'est en g\u00e9n\u00e9ral ici que l'on va d\u00e9finir le code m\u00e9tier des stories complexes. Le code est relativement parlant, mais il contient une abstraction suppl\u00e9mentaire, SearchConnector . SearchConnector est la classe qui d\u00e9finit le comportement sp\u00e9cifique \u00e0 chaque connecteur, et les annotations @GAHandler(GASearchConnector::class) et @MessengerHandler(MessengerSearchConnector::class) indiquent les impl\u00e9mentations correspondantes pour les diff\u00e9rents connecteurs support\u00e9s (respectivement Google Assistant et Messenger). Que se passerait t'il si il n'avait pas de connecteur pour Google Assistant par exemple? La m\u00e9thode connector?.sendFirstJourney(journeys.first()) n'enverrait pas la r\u00e9ponse finale, puisque connector serait null . Utiliser ConnectorDef \u00b6 Voici maintenant une version simplifi\u00e9e de SearchConnector : sealed class SearchConnector ( context : SearchDef ) : ConnectorDef < SearchDef >( context ) { fun Section . title (): CharSequence = i18n ( \"{0} - {1}\" , from , to ) fun sendFirstJourney ( journey : Journey ) = withMessage ( sendFirstJourney ( journey . publicTransportSections ())) abstract fun sendFirstJourney ( sections : List < Section >): ConnectorMessage } et son impl\u00e9mentation pour Messenger : class MessengerSearchConnector ( context : SearchDef ) : SearchConnector ( context ) { override fun sendFirstJourney ( sections : List < Section >): ConnectorMessage = flexibleListTemplate ( sections . map { section -> with ( section ) { listElement ( title (), content (), trainImage ) } }, compact ) } Le code sp\u00e9cifique \u00e0 chaque connecteur est ainsi correctement d\u00e9coupl\u00e9. Le code commun \u00e0 chaque connecteur est pr\u00e9sent dans SearchConnector et le comportement sp\u00e9cifique \u00e0 chaque connecteur se trouve dans les classes d\u00e9di\u00e9es. Utiliser StoryStep \u00b6 Parfois il est n\u00e9cessaire de se souvenir de l'\u00e9tape \u00e0 laquelle l'utilisateur se trouve dans la story courante. Pour cela Tock met \u00e0 disposition la notion de StoryStep . Il existe deux types de StoryStep. SimpleStoryStep \u00b6 A utiliser dans les cas simples, pour lequels on va g\u00e9rer le comportement induit directement. enum class MyStep : SimpleStoryStep { a , b } val story = storyWithSteps < MyStep >( \"intent\" ) { if ( step == a ) { // ... } else if ( step == b ) { // ... } else { //default case } } Pour modifier l'\u00e9tape courante, deux m\u00e9thodes sont disponibles : Modifier manuellement la step val story = storyWithSteps < MyStep >( \"intent\" ) { //(...) step = MyStep . a // l'\u00e9tape sera persist\u00e9e tant que nous resterons dans cette story } Utiliser les boutons ou autres quick replies Plus de d\u00e9tails sur ce sujet ici . Les StoryStep avec comportement \u00b6 Dans des cas plus complexes, on souhaite pouvoir d\u00e9finir un comportement pour chaque \u00e9tape. L'utilisation de HandlerDef est alors un pr\u00e9requis. enum class MySteps : StoryStep < MyHandlerDef > { //pas de comportement sp\u00e9cifique display , select { // la step \"select\" sera automatiquement s\u00e9lectionn\u00e9e si la sous-intention select est d\u00e9tect\u00e9e override val intent : IntentAware ? = SecondaryIntent . select //dans ce cas la r\u00e9ponse suivante sera apport\u00e9e override fun answer (): MyHandlerDef .() -> Any ? = { end ( \"I don't know yet how to select something\" ) } }, disruption { //seule la r\u00e9ponse est configur\u00e9e override fun answer (): ScoreboardDef .() -> Any ? = { end ( \"some perturbation\" ) } }; } Davantage d'options de configuration sont disponibles. Consultez la description de StoryStep . Postback buttons & quick replies \u00b6 Messenger met \u00e0 disposition ce type de bouton, et la plupart des connecteurs avec interface graphique font de m\u00eame. Tock permet de d\u00e9finir l'action effectu\u00e9e suite \u00e0 un clic sur ces boutons. Dans l'exemple suivant, le bouton redirigera vers l'intention \"search\". buttonsTemplate ( \"The bot is very limited! Only itineraries are supported :)\" , postbackButton ( \"Itineraries\" , search ) ) Il est possible de d\u00e9finir \u00e9galement une StoryStep et des param\u00e8tres d\u00e9di\u00e9s : //pour d\u00e9finir des param\u00e8tres, la pratique recommand\u00e9e est d'\u00e9tendre l'interface ParameterKey enum class ChoiceParameter : ParameterKey { nextResultDate , nextResultOrigin } buttonsTemplate ( \"The bot is very limited! Only itineraries are supported :)\" , postbackButton ( \"Itineraries\" , intent = search , //si aucune step n'est indiqu\u00e9e, c'est la step courante qui est utilis\u00e9e step = MyStep . a , parameters = //ce param\u00e8tre est stock\u00e9 sous forme de cha\u00eene de caract\u00e8re (les crochets sont utilis\u00e9s) nextResultDate [ nextDate ] + //ce param\u00e8tre est stock\u00e9 en json (les parenth\u00e8ses sont utilis\u00e9es) nextResultOrigin ( origin ) ) ) Pour r\u00e9cup\u00e9rer les param\u00e8tres du bouton sur lequel on a cliqu\u00e9 : val isClick = isChoiceAction () val nextDate = choice ( nextResultDate ) val nextOrigin : Locality = action . jsonChoice ( nextResultOrigin ) D\u00e9finir son propre connecteur \u00b6 Il est possible de d\u00e9velopper son propre connecteur. Pour cela quatres \u00e9tapes sont n\u00e9cessaires : 1) Impl\u00e9menter l'interface Connector Voici un exemple d'impl\u00e9mentation : val testConnectorType = ConnectorType ( \"test\" ) class TestConnector ( val applicationId : String , val path : String ) : Connector { override val connectorType : ConnectorType = testConnectorType override fun register ( controller : ConnectorController ) { controller . registerServices ( path ) { router -> //main API router . post ( \"$path/message\" ). blockingHandler { context -> //ConnectorRequest est mon objet m\u00e9tier pass\u00e9 par l'appli front val message : ConnectorRequest = mapper . readValue ( context . bodyAsString ) //transformation de l'objet m\u00e9tier en Event tock val event = readUserMessage ( message ) // on passe l'\u00e9v\u00e8nement au framework val callback = TestConnectorCallback ( applicationId , message . userId , context , controller ) controller . handle ( event , ConnectorData ( callback )) } } } override fun send ( event : Event , callback : ConnectorCallback , delayInMs : Long ) { callback as TestConnectorCallback if ( event is Action ) { //on enregistre l'action callback . actions . add ( event ) //si c'est la derni\u00e8re action \u00e0 envoyer, on envoie la r\u00e9ponse if ( event . metadata . lastAnswer ) { callback . sendAnswer () } } else { logger . trace { \"unsupported event: $event\" } } } } // pour r\u00e9cup\u00e9rer toutes les actions avant envoi class TestConnectorCallback ( override val applicationId : String , val userId : String , val context : RoutingContext , val controller : ConnectorController , val actions : MutableList < Action > = CopyOnWriteArrayList ()): ConnectorCallbackBase ( applicationId , testConnectorType ) { internal fun sendAnswer () { //on transforme la liste des r\u00e9ponses Tock en r\u00e9ponse m\u00e9tier val response = mapper . writeValueAsString ( actions . map {...}) //puis on envoie la r\u00e9ponse context . response (). end ( response ) } } 2) Impl\u00e9menter l'interface ConnectorProvider Voici un exemple d'impl\u00e9mentation : object TestConnectorProvider : ConnectorProvider { override val connectorType : ConnectorType = testConnectorType override fun connector ( connectorConfiguration : ConnectorConfiguration ): Connector { return TestConnector ( connectorConfiguration . connectorId , connectorConfiguration . path ) } } class TestConnectorProviderService : ConnectorProvider by TestConnectorProvider 3) Rendre disponible ce connecteur via un Service Loader En placant un fichier META-INF/services/fr.vsct.tock.bot.connector.ConnectorProvider dans le classpath, contenant le nom de la classe : mypackage.TestConnectorProviderService 4) Rajouter toutes les classes et fichiers cr\u00e9\u00e9s dans le classpath de l'admin et du bot. Le nouveau connecteur doit alors \u00eatre disponible dans l'interface d'administration \"Bot Configurations\".","title":"D\u00e9velopper"},{"location":"developper/#le-langage-dedie-au-conversationnel-de-tock","text":"Pour d\u00e9velopper un bot ou un assistant avec Tock en mode int\u00e9gr\u00e9, il est n\u00e9cessaire aujourd'hui de d\u00e9velopper dans un Domain Specifique Language (DSL) d\u00e9velopp\u00e9 en Kotlin via un IDE. Dans ce mode de d\u00e9veloppement, il est n\u00e9cessaire de disposer d'une connexion \u00e0 la base de donn\u00e9e de Tock. Pour appr\u00e9hender compl\u00e8tement ce qui va suivre, il est recommand\u00e9 de ma\u00eetriser les bases du langage Kotlin.","title":"Le langage d\u00e9di\u00e9 au conversationnel de Tock"},{"location":"developper/#ajouter-la-dependance-bot-toolkit","text":"Pour utiliser le framework conversationnel, il faut ajouter la d\u00e9pendance bot-tookit \u00e0 votre projet. Avec Maven : <dependency> <groupId> fr.vsct.tock </groupId> <artifactId> bot-toolkit </artifactId> <version> 19.3.2 </version> </dependency> ou Gradle : compile 'fr.vsct.tock:bot-toolkit:19.3.2'","title":"Ajouter la d\u00e9pendance bot-toolkit"},{"location":"developper/#un-bot-est-un-ensemble-de-stories","text":"Voici comment le bot open data est d\u00e9fini : val openBot = bot ( \"bot_open_data\" , stories = listOf ( greetings , departures , arrivals , search ), hello = greetings ) Ce bot comporte un identifiant (obligatoire - \"bot_open_data\") et une liste de \"Story\" . Une Story est un regroupement fonctionnel qui correspond \u00e0 une intention principale et, de mani\u00e8re optionelle, \u00e0 une ou plusieurs intentions dites \"secondaires\". Ici le bot d\u00e9finit 4 Stories , greetings, departures, arrivals et search. greetings est par ailleurs ( hello = greetings ) indiqu\u00e9e comme \u00e9tant la story pr\u00e9sent\u00e9e par d\u00e9faut lors du d\u00e9but d'une conversation.","title":"Un bot est un ensemble de Stories"},{"location":"developper/#une-story-simple","text":"Comment d\u00e9finit-on une Story? Voici une premi\u00e8re version simplifi\u00e9e de la Story greetings : val greetings = story ( \"greetings\" ) { send ( \"Bienvenue chez le Bot Open Data Sncf! :)\" ) end ( \"Il s'agit d'un bot de d\u00e9monstration du framework Tock : https://github.com/voyages-sncf-technologies/tock\" ) } Notez que dans le corps de la fonction, this est de type BotBus , \u00e0 partir duquel vous pouvez interagir avec l'utilisateur, et qui permet \u00e9galement d'acc\u00e8der \u00e0 tous les \u00e9lements contextuels disponibles. Concr\u00e8tement sela signifie que quand l'intention greetings sera d\u00e9tect\u00e9e par le mod\u00e8le NLP, la fonction ci-dessus sera appel\u00e9e par le framework Tock. Le bot envoie donc successivement une premi\u00e8re phrase de r\u00e9ponse ( bus.send() ), puis un deuxi\u00e8me en indiquant que c'est la derni\u00e8re phrase de sa r\u00e9ponse \u00e0 l'aide d'un bus.end() . Voici maintenant la version compl\u00e8te de greetings : val greetings = story ( \"greetings\" ) { //cleanup state resetDialogState () send ( \"Bienvenue chez le Bot Open Data Sncf! :)\" ) send ( \"Il s'agit d'un bot de d\u00e9monstration du framework Tock : https://github.com/voyages-sncf-technologies/tock\" ) withMessenger { buttonsTemplate ( \"Il est volontairement tr\u00e8s limit\u00e9, mais demandez lui un itin\u00e9raire ou les d\u00e9parts \u00e0 partir d'une gare et constatez le r\u00e9sultat! :) \" , postbackButton ( \"Itin\u00e9raires\" , search ), postbackButton ( \"D\u00e9parts\" , Departures ), postbackButton ( \"Arriv\u00e9es\" , Arrivals ) ) } withGoogleAssistant { gaMessage ( \"Il est volontairement tr\u00e8s limit\u00e9, mais demandez lui un itin\u00e9raire ou les d\u00e9parts \u00e0 partir d'une gare et constatez le r\u00e9sultat! :) \" , \"Itin\u00e9raires\" , \"D\u00e9parts\" , \"Arriv\u00e9es\" ) } end () } Deux notions ont \u00e9t\u00e9 ajout\u00e9es : resetDialogState() qui permet de repartir d'un contexte utilisateur vide (en oubliant les \u00e9ventuels \u00e9changes pr\u00e9c\u00e9dents) les m\u00e9thodes withMessenger{} et withGoogleAssistant{} qui permettent de d\u00e9finir des r\u00e9ponses sp\u00e9cifiques pour chaque connecteur. Ici un texte avec des boutons pour Messenger, et un texte avec des suggestions pour Google Assistant.","title":"Une Story simple"},{"location":"developper/#demarrer-et-connecter-le-bot","text":"Pour d\u00e9marrer le bot, il suffit de rajouter dans votre main principal l'appel suivant: registerAndInstallBot ( openBot ) o\u00f9 la variable openBot est le bot que vous avez d\u00e9fini au d\u00e9part. Une fois le bot d\u00e9marr\u00e9, il est \u00e9galement n\u00e9cessaire de sp\u00e9cifier quels connecteurs sont utilis\u00e9s dans l'interface d'administration du bot, du menu Configuration -> Bot Configurations -> Create a new configuration. La documentation pour chaque connecteur se trouve dans le README des projects correspondants. Cinq par d\u00e9faut sont disponibles \u00e0 l'heure actuelle : Messenger Google Assistant Slack RocketChat Twitter WhatsApp Teams Alexa - A noter que dans le cas d'Alexa, le mod\u00e8le NLP est forc\u00e9ment chez Amazon. Seul le framework conversationel de Tock peut donc \u00eatre utilis\u00e9.","title":"D\u00e9marrer et connecter le bot"},{"location":"developper/#aller-un-peu-plus-loin","text":"Bien s\u00fbr, le Story Handler de greetings ne d\u00e9pend pas du contexte : la r\u00e9ponse est toujours la m\u00eame. Pour le d\u00e9veloppement de stories complexes, nous avons besoin d'une abstraction suppl\u00e9mentaire.","title":"Aller un peu plus loin"},{"location":"developper/#intentions-secondaires","text":"Voici le d\u00e9but de la d\u00e9finition de la story search : val search = storyDef < SearchDef >( \"search\" , otherStarterIntents = setOf ( indicate_origin ), secondaryIntents = setOf ( indicate_location )) { } La story search d\u00e9finit une intention secondaire \"de d\u00e9marrage\" ( indicate_origin ) et une intention secondaire simple ( indicate_location ) Une intention secondaire \"de d\u00e9marrage\" est semblable en tout point \u00e0 une intention principale : d\u00e8s que cette intention est d\u00e9tect\u00e9e, la story search va \u00eatre ex\u00e9cut\u00e9e, si la story courante ne poss\u00e8de pas cette intention en tant qu'intention secondaire. Pour une intention secondaire simple, par contre, la story ne sera ex\u00e9cut\u00e9e que si la story courante du contexte est d\u00e9j\u00e0 la story search. Plusieurs story diff\u00e9rentes peuvent donc partager les m\u00eames intentions secondaires.","title":"Intentions secondaires"},{"location":"developper/#manipuler-les-entites","text":"Pour r\u00e9cup\u00e9rer les valeurs des entit\u00e9s, une bonne pratique est de d\u00e9finir des extensions . Par exemple voici le code utilis\u00e9 pour r\u00e9cup\u00e9rer l'entit\u00e9 destination : val destinationEntity = openBot . entity ( \"location\" , \"destination\" ) var BotBus . destination : Place ? get () = place ( destinationEntity ) set ( value ) = setPlace ( destinationEntity , value ) private fun BotBus . place ( entity : Entity ): Place ? = entityValue ( entity , :: placeValue ) ?. place private fun BotBus . setPlace ( entity : Entity , place : Place ?) = changeEntityValue ( entity , place ?. let { PlaceValue ( place ) }) Une entit\u00e9 de type \"location\" et de role \"destination\" est cr\u00e9\u00e9e. Il s'agit de l'entit\u00e9 correspondante dans le mod\u00e8le NLP. Une variable destination est d\u00e9finie, qui va simplifier la manipulation de cette entit\u00e9 dans le code m\u00e9tier. Cette variable contient la valeur actuelle de la destination dans le contexte utilisateur. Voici une version compl\u00e9t\u00e9e de la story search qui utilise destination : val search = storyDef < SearchDef >( \"search\" , setOf ( indicate_origin ), setOf ( indicate_location )) { //check mandatory entities when { destination == null -> end ( \"Pour quelle destination?\" ) origin == null -> end ( \"Pour quelle origine?\" ) departureDate == null -> end ( \"Quand souhaitez-vous partir?\" ) } } Si il n'y a pas de valeur dans le contexte courant pour la destination, le bot demande de sp\u00e9cifier la destination et en reste l\u00e0. Idem pour l'origine ou la date de d\u00e9part. Si les 3 valeurs obligatoires sont sp\u00e9cifi\u00e9es, il passe \u00e0 la r\u00e9ponse proprement dite d\u00e9velopp\u00e9e dans la classe ( SearchDef ). La version compl\u00e8te de cette premi\u00e8re partie du code est la suivante : val search = storyDef < SearchDef >( \"search\" , setOf ( indicate_origin ), setOf ( indicate_location )) { //handle generic location intent if ( isIntent ( indicate_location ) && location != null ) { if ( destination == null || origin != null ) { destination = returnsAndRemoveLocation () } else { origin = returnsAndRemoveLocation () } } //check mandatory entities when { destination == null -> end ( \"Pour quelle destination?\" ) origin == null -> end ( \"Pour quelle origine?\" ) departureDate == null -> end ( \"Quand souhaitez-vous partir?\" ) } } Dans le cas o\u00f9 l'intention d\u00e9tect\u00e9e est indicate_location , nous ne savons pas si la localit\u00e9 indiqu\u00e9e repr\u00e9sente l'origine ou la destination. Il est donc cod\u00e9 une r\u00e8gle simple : Si il existe d\u00e9j\u00e0 dans le contexte une origine et pas de destination, la nouvelle localit\u00e9 est en fait la destination. Sinon, il s'agit de l'origine.","title":"Manipuler les entit\u00e9s"},{"location":"developper/#utiliser-handlerdef","text":"Dans la d\u00e9finition de la story search ci-dessus, vous avez pu noter le typage g\u00e9n\u00e9rique SearchDef . Voici le code de cette classe : @GAHandler ( GASearchConnector :: class ) @MessengerHandler ( MessengerSearchConnector :: class ) class SearchDef ( bus : BotBus ) : HandlerDef < SearchConnector >( bus ) { private val d : Place = bus . destination !! private val o : Place = bus . origin !! private val date : LocalDateTime = bus . departureDate !! override fun answer () { send ( \"De {0} \u00e0 {1}\" , o , d ) send ( \"D\u00e9part le {0}\" , date by datetimeFormat ) val journeys = SncfOpenDataClient . journey ( o , d , date ) if ( journeys . isEmpty ()) { end ( \"D\u00e9sol\u00e9, aucun itin\u00e9raire trouv\u00e9 :(\" ) } else { send ( \"Voici la premi\u00e8re proposition :\" ) connector ?. sendFirstJourney ( journeys . first ()) end () } } } SearchDef \u00e9tend HandlerDef qui est un alias d'une classe du framework Tock. C'est en g\u00e9n\u00e9ral ici que l'on va d\u00e9finir le code m\u00e9tier des stories complexes. Le code est relativement parlant, mais il contient une abstraction suppl\u00e9mentaire, SearchConnector . SearchConnector est la classe qui d\u00e9finit le comportement sp\u00e9cifique \u00e0 chaque connecteur, et les annotations @GAHandler(GASearchConnector::class) et @MessengerHandler(MessengerSearchConnector::class) indiquent les impl\u00e9mentations correspondantes pour les diff\u00e9rents connecteurs support\u00e9s (respectivement Google Assistant et Messenger). Que se passerait t'il si il n'avait pas de connecteur pour Google Assistant par exemple? La m\u00e9thode connector?.sendFirstJourney(journeys.first()) n'enverrait pas la r\u00e9ponse finale, puisque connector serait null .","title":"Utiliser HandlerDef"},{"location":"developper/#utiliser-connectordef","text":"Voici maintenant une version simplifi\u00e9e de SearchConnector : sealed class SearchConnector ( context : SearchDef ) : ConnectorDef < SearchDef >( context ) { fun Section . title (): CharSequence = i18n ( \"{0} - {1}\" , from , to ) fun sendFirstJourney ( journey : Journey ) = withMessage ( sendFirstJourney ( journey . publicTransportSections ())) abstract fun sendFirstJourney ( sections : List < Section >): ConnectorMessage } et son impl\u00e9mentation pour Messenger : class MessengerSearchConnector ( context : SearchDef ) : SearchConnector ( context ) { override fun sendFirstJourney ( sections : List < Section >): ConnectorMessage = flexibleListTemplate ( sections . map { section -> with ( section ) { listElement ( title (), content (), trainImage ) } }, compact ) } Le code sp\u00e9cifique \u00e0 chaque connecteur est ainsi correctement d\u00e9coupl\u00e9. Le code commun \u00e0 chaque connecteur est pr\u00e9sent dans SearchConnector et le comportement sp\u00e9cifique \u00e0 chaque connecteur se trouve dans les classes d\u00e9di\u00e9es.","title":"Utiliser ConnectorDef"},{"location":"developper/#utiliser-storystep","text":"Parfois il est n\u00e9cessaire de se souvenir de l'\u00e9tape \u00e0 laquelle l'utilisateur se trouve dans la story courante. Pour cela Tock met \u00e0 disposition la notion de StoryStep . Il existe deux types de StoryStep.","title":"Utiliser StoryStep"},{"location":"developper/#simplestorystep","text":"A utiliser dans les cas simples, pour lequels on va g\u00e9rer le comportement induit directement. enum class MyStep : SimpleStoryStep { a , b } val story = storyWithSteps < MyStep >( \"intent\" ) { if ( step == a ) { // ... } else if ( step == b ) { // ... } else { //default case } } Pour modifier l'\u00e9tape courante, deux m\u00e9thodes sont disponibles : Modifier manuellement la step val story = storyWithSteps < MyStep >( \"intent\" ) { //(...) step = MyStep . a // l'\u00e9tape sera persist\u00e9e tant que nous resterons dans cette story } Utiliser les boutons ou autres quick replies Plus de d\u00e9tails sur ce sujet ici .","title":"SimpleStoryStep"},{"location":"developper/#les-storystep-avec-comportement","text":"Dans des cas plus complexes, on souhaite pouvoir d\u00e9finir un comportement pour chaque \u00e9tape. L'utilisation de HandlerDef est alors un pr\u00e9requis. enum class MySteps : StoryStep < MyHandlerDef > { //pas de comportement sp\u00e9cifique display , select { // la step \"select\" sera automatiquement s\u00e9lectionn\u00e9e si la sous-intention select est d\u00e9tect\u00e9e override val intent : IntentAware ? = SecondaryIntent . select //dans ce cas la r\u00e9ponse suivante sera apport\u00e9e override fun answer (): MyHandlerDef .() -> Any ? = { end ( \"I don't know yet how to select something\" ) } }, disruption { //seule la r\u00e9ponse est configur\u00e9e override fun answer (): ScoreboardDef .() -> Any ? = { end ( \"some perturbation\" ) } }; } Davantage d'options de configuration sont disponibles. Consultez la description de StoryStep .","title":"Les StoryStep avec comportement"},{"location":"developper/#postback-buttons-quick-replies","text":"Messenger met \u00e0 disposition ce type de bouton, et la plupart des connecteurs avec interface graphique font de m\u00eame. Tock permet de d\u00e9finir l'action effectu\u00e9e suite \u00e0 un clic sur ces boutons. Dans l'exemple suivant, le bouton redirigera vers l'intention \"search\". buttonsTemplate ( \"The bot is very limited! Only itineraries are supported :)\" , postbackButton ( \"Itineraries\" , search ) ) Il est possible de d\u00e9finir \u00e9galement une StoryStep et des param\u00e8tres d\u00e9di\u00e9s : //pour d\u00e9finir des param\u00e8tres, la pratique recommand\u00e9e est d'\u00e9tendre l'interface ParameterKey enum class ChoiceParameter : ParameterKey { nextResultDate , nextResultOrigin } buttonsTemplate ( \"The bot is very limited! Only itineraries are supported :)\" , postbackButton ( \"Itineraries\" , intent = search , //si aucune step n'est indiqu\u00e9e, c'est la step courante qui est utilis\u00e9e step = MyStep . a , parameters = //ce param\u00e8tre est stock\u00e9 sous forme de cha\u00eene de caract\u00e8re (les crochets sont utilis\u00e9s) nextResultDate [ nextDate ] + //ce param\u00e8tre est stock\u00e9 en json (les parenth\u00e8ses sont utilis\u00e9es) nextResultOrigin ( origin ) ) ) Pour r\u00e9cup\u00e9rer les param\u00e8tres du bouton sur lequel on a cliqu\u00e9 : val isClick = isChoiceAction () val nextDate = choice ( nextResultDate ) val nextOrigin : Locality = action . jsonChoice ( nextResultOrigin )","title":"Postback buttons &amp; quick replies"},{"location":"developper/#definir-son-propre-connecteur","text":"Il est possible de d\u00e9velopper son propre connecteur. Pour cela quatres \u00e9tapes sont n\u00e9cessaires : 1) Impl\u00e9menter l'interface Connector Voici un exemple d'impl\u00e9mentation : val testConnectorType = ConnectorType ( \"test\" ) class TestConnector ( val applicationId : String , val path : String ) : Connector { override val connectorType : ConnectorType = testConnectorType override fun register ( controller : ConnectorController ) { controller . registerServices ( path ) { router -> //main API router . post ( \"$path/message\" ). blockingHandler { context -> //ConnectorRequest est mon objet m\u00e9tier pass\u00e9 par l'appli front val message : ConnectorRequest = mapper . readValue ( context . bodyAsString ) //transformation de l'objet m\u00e9tier en Event tock val event = readUserMessage ( message ) // on passe l'\u00e9v\u00e8nement au framework val callback = TestConnectorCallback ( applicationId , message . userId , context , controller ) controller . handle ( event , ConnectorData ( callback )) } } } override fun send ( event : Event , callback : ConnectorCallback , delayInMs : Long ) { callback as TestConnectorCallback if ( event is Action ) { //on enregistre l'action callback . actions . add ( event ) //si c'est la derni\u00e8re action \u00e0 envoyer, on envoie la r\u00e9ponse if ( event . metadata . lastAnswer ) { callback . sendAnswer () } } else { logger . trace { \"unsupported event: $event\" } } } } // pour r\u00e9cup\u00e9rer toutes les actions avant envoi class TestConnectorCallback ( override val applicationId : String , val userId : String , val context : RoutingContext , val controller : ConnectorController , val actions : MutableList < Action > = CopyOnWriteArrayList ()): ConnectorCallbackBase ( applicationId , testConnectorType ) { internal fun sendAnswer () { //on transforme la liste des r\u00e9ponses Tock en r\u00e9ponse m\u00e9tier val response = mapper . writeValueAsString ( actions . map {...}) //puis on envoie la r\u00e9ponse context . response (). end ( response ) } } 2) Impl\u00e9menter l'interface ConnectorProvider Voici un exemple d'impl\u00e9mentation : object TestConnectorProvider : ConnectorProvider { override val connectorType : ConnectorType = testConnectorType override fun connector ( connectorConfiguration : ConnectorConfiguration ): Connector { return TestConnector ( connectorConfiguration . connectorId , connectorConfiguration . path ) } } class TestConnectorProviderService : ConnectorProvider by TestConnectorProvider 3) Rendre disponible ce connecteur via un Service Loader En placant un fichier META-INF/services/fr.vsct.tock.bot.connector.ConnectorProvider dans le classpath, contenant le nom de la classe : mypackage.TestConnectorProviderService 4) Rajouter toutes les classes et fichiers cr\u00e9\u00e9s dans le classpath de l'admin et du bot. Le nouveau connecteur doit alors \u00eatre disponible dans l'interface d'administration \"Bot Configurations\".","title":"D\u00e9finir son propre connecteur"},{"location":"evaluer-la-pertinence-du-modele/","text":"Evaluer la pertinence du mod\u00e8le NLP \u00b6 Donn\u00e9es disponibles \u00b6 Cinq onglets permettent de contr\u00f4ler la pertinence du mod\u00e8le : Stats : statistiques minimales qui permettent de suivre la qualit\u00e9 du mod\u00e8le en production. Elles comprennent: l'auto-\u00e9valuation du mod\u00e8le sur sa pertinence en terme de reconnaissance d'intention et d'entit\u00e9s le nombre d'appels et le nombre d'erreurs le temps moyen d'ex\u00e9cution Test Trend : \u00e9volution de la pertinence des tests partiels de mod\u00e8le Intent Errors : la liste des erreurs d'intention (vraies ou fausses) trouv\u00e9es lors des tests partiels de mod\u00e8le Entity Errors : la liste des erreurs d'entit\u00e9 (vraies ou fausses) trouv\u00e9es lors des tests partiels de mod\u00e8le Model Builds : la liste des constructions des mod\u00e8les avec notamment le type de mod\u00e8le, le nombre de phrases et la dur\u00e9e de construction Tests partiels de mod\u00e8le \u00b6 Les tests partiels de mod\u00e8le constituent un moyen classique de d\u00e9tecter les erreurs de qualification, ou les probl\u00e8mes de proximit\u00e9 des intentions (ou entit\u00e9s) entre elles. Il s'agit de prendre une partie du mod\u00e8le actuelle au hasard (par exemple 90% des phrases du mod\u00e8le) afin de construire un mod\u00e8le l\u00e9g\u00e8rement moins pertinent, puis de tester les 10% restant avec ce nouveau mod\u00e8le. Une fois le principe pos\u00e9, il ne reste plus qu'\u00e0 r\u00e9p\u00e9ter le processus un certain nombre de fois pour que les erreurs les plus fr\u00e9quentes soient pr\u00e9sent\u00e9es \u00e0 un correcteur manuel. Ces tests partiels ne pr\u00e9sentent une utilit\u00e9 qu'avec des mod\u00e8les d\u00e9j\u00e0 cons\u00e9quents. Lancement des tests \u00b6 Par d\u00e9faut les tests sont programm\u00e9s pour \u00eatre lanc\u00e9s de minuit \u00e0 5h du matin, toutes les 10 minutes. Il est possible de configurer ce comportement avec la propri\u00e9t\u00e9 tock_test_model_timeframe (=0,5 par d\u00e9faut) Intentions en erreur \u00b6 C'est l'objet de l'onglet Intent Errors . Voici par exemple une copie d'\u00e9cran pour le mod\u00e8le bot open-data. Comme il s'agit d'un mod\u00e8le d'exemple, aucune vraie erreur n'a \u00e9t\u00e9 d\u00e9tect\u00e9e. On peut tout de m\u00eame constater que dans certains cas le mod\u00e8le se trompe syst\u00e9matiquement avec une probabilit\u00e9 \u00e9lev\u00e9e. Pour chaque phrase il est possible via la colonne Actions de confirmer que le mod\u00e8le de base est correct ( Validate Intent ) ou de corriger l'\u00e9ventuelle erreur d\u00e9tect\u00e9e ( Change The Intent ). Entit\u00e9s en erreur \u00b6 Elles sont consultables de mani\u00e8re sym\u00e9trique via l'onglet Entity Errors .","title":"Evaluer la pertinence du mod\u00e8le"},{"location":"evaluer-la-pertinence-du-modele/#evaluer-la-pertinence-du-modele-nlp","text":"","title":"Evaluer la pertinence du mod\u00e8le NLP"},{"location":"evaluer-la-pertinence-du-modele/#donnees-disponibles","text":"Cinq onglets permettent de contr\u00f4ler la pertinence du mod\u00e8le : Stats : statistiques minimales qui permettent de suivre la qualit\u00e9 du mod\u00e8le en production. Elles comprennent: l'auto-\u00e9valuation du mod\u00e8le sur sa pertinence en terme de reconnaissance d'intention et d'entit\u00e9s le nombre d'appels et le nombre d'erreurs le temps moyen d'ex\u00e9cution Test Trend : \u00e9volution de la pertinence des tests partiels de mod\u00e8le Intent Errors : la liste des erreurs d'intention (vraies ou fausses) trouv\u00e9es lors des tests partiels de mod\u00e8le Entity Errors : la liste des erreurs d'entit\u00e9 (vraies ou fausses) trouv\u00e9es lors des tests partiels de mod\u00e8le Model Builds : la liste des constructions des mod\u00e8les avec notamment le type de mod\u00e8le, le nombre de phrases et la dur\u00e9e de construction","title":"Donn\u00e9es disponibles"},{"location":"evaluer-la-pertinence-du-modele/#tests-partiels-de-modele","text":"Les tests partiels de mod\u00e8le constituent un moyen classique de d\u00e9tecter les erreurs de qualification, ou les probl\u00e8mes de proximit\u00e9 des intentions (ou entit\u00e9s) entre elles. Il s'agit de prendre une partie du mod\u00e8le actuelle au hasard (par exemple 90% des phrases du mod\u00e8le) afin de construire un mod\u00e8le l\u00e9g\u00e8rement moins pertinent, puis de tester les 10% restant avec ce nouveau mod\u00e8le. Une fois le principe pos\u00e9, il ne reste plus qu'\u00e0 r\u00e9p\u00e9ter le processus un certain nombre de fois pour que les erreurs les plus fr\u00e9quentes soient pr\u00e9sent\u00e9es \u00e0 un correcteur manuel. Ces tests partiels ne pr\u00e9sentent une utilit\u00e9 qu'avec des mod\u00e8les d\u00e9j\u00e0 cons\u00e9quents.","title":"Tests partiels de mod\u00e8le"},{"location":"evaluer-la-pertinence-du-modele/#lancement-des-tests","text":"Par d\u00e9faut les tests sont programm\u00e9s pour \u00eatre lanc\u00e9s de minuit \u00e0 5h du matin, toutes les 10 minutes. Il est possible de configurer ce comportement avec la propri\u00e9t\u00e9 tock_test_model_timeframe (=0,5 par d\u00e9faut)","title":"Lancement des tests"},{"location":"evaluer-la-pertinence-du-modele/#intentions-en-erreur","text":"C'est l'objet de l'onglet Intent Errors . Voici par exemple une copie d'\u00e9cran pour le mod\u00e8le bot open-data. Comme il s'agit d'un mod\u00e8le d'exemple, aucune vraie erreur n'a \u00e9t\u00e9 d\u00e9tect\u00e9e. On peut tout de m\u00eame constater que dans certains cas le mod\u00e8le se trompe syst\u00e9matiquement avec une probabilit\u00e9 \u00e9lev\u00e9e. Pour chaque phrase il est possible via la colonne Actions de confirmer que le mod\u00e8le de base est correct ( Validate Intent ) ou de corriger l'\u00e9ventuelle erreur d\u00e9tect\u00e9e ( Change The Intent ).","title":"Intentions en erreur"},{"location":"evaluer-la-pertinence-du-modele/#entites-en-erreur","text":"Elles sont consultables de mani\u00e8re sym\u00e9trique via l'onglet Entity Errors .","title":"Entit\u00e9s en erreur"},{"location":"i18n/","text":"Traduire et moduler les r\u00e9ponses du bot \u00b6 Activation \u00b6 La framework Tock met \u00e0 disposition un framework complet d'internationalisation. Il est d\u00e9sactiv\u00e9 par d\u00e9faut pour le mode \"Bot int\u00e9gr\u00e9\". Pour l'activer, il est n\u00e9cessaire d'utiliser ce code lors du d\u00e9marrage du bot : Translator . enabled = true ou de passer la propri\u00e9t\u00e9 -Dtock_i18n_enabled=true \u00e0 la JVM. il est activ\u00e9 par d\u00e9faut pour le mode \"Bot API\". Utilisation dans le code \u00b6 Principe de fonctionnement \u00b6 Le code ne change pas une fois l'internationalisation activ\u00e9e. Par exemple : send ( \"Arrival at {0}\" , time ) est un code valide que le module soit activ\u00e9 ou non. Par contre, \u00e0 l'ex\u00e9cution, le comportement diff\u00e8re significativement. Si l'internationalisation est activ\u00e9e, les op\u00e9rations suivantes vont \u00eatre effectu\u00e9es : Une cl\u00e9 va \u00eatre g\u00e9n\u00e9r\u00e9e \u00e0 partir du texte pass\u00e9 en param\u00e8tre, en fonction du namespace (l'organisation du cr\u00e9ateur du bot) et de la story dans laquelle est demand\u00e9 ce libell\u00e9. Dans le cas ci-dessus, cela devrait ressembler \u00e0 app_arrivals_Arrival at {0} o\u00f9 app est le namespace et arrivals l'intention principale de la story. Tock v\u00e9rifie ensuite si cette cl\u00e9 est d\u00e9j\u00e0 pr\u00e9sente en base. Si c'est le cas, il utilise le libell\u00e9 pr\u00e9sent en base pour la langue demand\u00e9e afin de trouver la traduction la plus appropri\u00e9e (le connecteur ou le type d'interface peuvent \u00e9galement \u00eatre pris en compte) Sinon, une cl\u00e9 est cr\u00e9\u00e9e en base avec le libell\u00e9 par d\u00e9faut (\"Arrival at {0}\" dans notre exemple) utilis\u00e9e pour la langue courante Il est ensuite possible de consulter et de modifier ce libell\u00e9 dans l'interface d'administration : Format support\u00e9 \u00b6 Le format support\u00e9 est celui du support i18n de java, en particulier celui de la classe MessageFormat en java. Cela inclut le support de ChoiceFormat : send ( \"There {0,choice,0#are no files|1#is one file|1<are {0,number,integer} files}.\" , 2 ) Par ailleurs, Tock met \u00e0 disposition une extension by pour les dates qui permet d'indiquer un format dans les param\u00e8tres : send ( \"Departure at {0}\" , departureDateTime by timeFormat ) Locale de l'utilisateur \u00b6 Quand c'est possible, la locale de l'utilisateur est import\u00e9e de celle de son compte. Par exemple, si le compte d'un utilisateur Messenger est configur\u00e9 en fran\u00e7ais, le fran\u00e7ais sera automatiquement utilis\u00e9 comme locale par Tock. Si il n'y a pas d'indication de locale, c'est la valeur defaultLocale qui est pris en compte. Il est possible de modifier cette valeur par d\u00e9faut avec la propri\u00e9t\u00e9 -Dtock_default_locale=fr Enfin il est possible de modifier la locale de l'utilisateur dans le bot lui-m\u00eame : userPreferences . locale = Locale . FRENCH Points d'attention \u00b6 Le module d'internationalisation de Tock est efficace, mais certaines pratiques, pourtant intuitives en Kotlin, sont \u00e0 bannir sous peine de mauvaises surprises. Par exemple, ce code fonctionne parfaitement bien avec le module i18n d\u00e9sactiv\u00e9. send ( \"There are $nb files\" ) //DANGER!! mais pose probl\u00e8me si il est activ\u00e9. En effet, un nouveau libell\u00e9 sera cr\u00e9\u00e9 pour chaque valeur diff\u00e9rente de la variable nb ! Si il est n\u00e9cessaire d'envoyer des r\u00e9ponses \"\u00e0 ne pas traduire\", utilisez les m\u00e9thodes BotBus.sendRaw , BotBus.endRaw ou String.raw send ( \"There are $nb files\" . raw ) //CORRECT send ( \"There are {0} files\" , nb ) //FORMAT A SUIVRE Le risque de collision entre deux libell\u00e9s est faible puisque l'intention principale de la story fait partie de la cl\u00e9. Si vous souhaitez cependant \u00e9viter tout risque, vous pouvez utiliser la m\u00e9thode i18nKey : send ( i18nKey ( \"my_unique_key\" , \"There are {0} files\" , nb )) Tester l'internationalisation \u00b6 Un exemple de dispositif de test est disponible dans le code source du bot d'exemple Il est n\u00e9cessaire d'\u00e9tendre l'extension de test pour ensuite indiquer la correspondance des libell\u00e9s \u00e0 tester. Il ne reste plus qu'\u00e0 indiquer la locale souhait\u00e9e : @Test fun `search story asks for departure date WHEN there is a destination and an origin but no departure date in context` () { ext . newRequest ( \"Recherche\" , search , locale = Locale . FRENCH ) { destination = lille origin = paris run () firstAnswer . assertText ( \"Quand souhaitez-vous partir?\" ) } } Interface d'administration \u00b6 Les diff\u00e9rentes variantes \u00b6 Chaque libell\u00e9 a une valeur par d\u00e9faut pour chaque langue du bot. Il est aussi possible d'indiquer des r\u00e9ponses sp\u00e9cifiques : par type de connecteur (Messenger, Google Assistant, Slack, etc.) par type d'interface (Texte ou voix) - c'est utile par exemple dans le cas de Google Assistant pour supporter les cas des parcours voix uniquement. Enfin, vous pouvez sp\u00e9cifier des alternatives . Dans ce cas, le bot utilise une des alternatives possible au hasard, \u00e0 chaque fois qu'il envoie une r\u00e9ponse \u00e0 l'utilisateur. Import et export des donn\u00e9es \u00b6 Une fonctionnalit\u00e9 d'import et d'export des libell\u00e9s au format json ou csv est disponible. Dans le cas d'un import, seuls les libell\u00e9s indiqu\u00e9s comme valid\u00e9s sont pris en compte.","title":"i18n"},{"location":"i18n/#traduire-et-moduler-les-reponses-du-bot","text":"","title":"Traduire et moduler les r\u00e9ponses du bot"},{"location":"i18n/#activation","text":"La framework Tock met \u00e0 disposition un framework complet d'internationalisation. Il est d\u00e9sactiv\u00e9 par d\u00e9faut pour le mode \"Bot int\u00e9gr\u00e9\". Pour l'activer, il est n\u00e9cessaire d'utiliser ce code lors du d\u00e9marrage du bot : Translator . enabled = true ou de passer la propri\u00e9t\u00e9 -Dtock_i18n_enabled=true \u00e0 la JVM. il est activ\u00e9 par d\u00e9faut pour le mode \"Bot API\".","title":"Activation"},{"location":"i18n/#utilisation-dans-le-code","text":"","title":"Utilisation dans le code"},{"location":"i18n/#principe-de-fonctionnement","text":"Le code ne change pas une fois l'internationalisation activ\u00e9e. Par exemple : send ( \"Arrival at {0}\" , time ) est un code valide que le module soit activ\u00e9 ou non. Par contre, \u00e0 l'ex\u00e9cution, le comportement diff\u00e8re significativement. Si l'internationalisation est activ\u00e9e, les op\u00e9rations suivantes vont \u00eatre effectu\u00e9es : Une cl\u00e9 va \u00eatre g\u00e9n\u00e9r\u00e9e \u00e0 partir du texte pass\u00e9 en param\u00e8tre, en fonction du namespace (l'organisation du cr\u00e9ateur du bot) et de la story dans laquelle est demand\u00e9 ce libell\u00e9. Dans le cas ci-dessus, cela devrait ressembler \u00e0 app_arrivals_Arrival at {0} o\u00f9 app est le namespace et arrivals l'intention principale de la story. Tock v\u00e9rifie ensuite si cette cl\u00e9 est d\u00e9j\u00e0 pr\u00e9sente en base. Si c'est le cas, il utilise le libell\u00e9 pr\u00e9sent en base pour la langue demand\u00e9e afin de trouver la traduction la plus appropri\u00e9e (le connecteur ou le type d'interface peuvent \u00e9galement \u00eatre pris en compte) Sinon, une cl\u00e9 est cr\u00e9\u00e9e en base avec le libell\u00e9 par d\u00e9faut (\"Arrival at {0}\" dans notre exemple) utilis\u00e9e pour la langue courante Il est ensuite possible de consulter et de modifier ce libell\u00e9 dans l'interface d'administration :","title":"Principe de fonctionnement"},{"location":"i18n/#format-supporte","text":"Le format support\u00e9 est celui du support i18n de java, en particulier celui de la classe MessageFormat en java. Cela inclut le support de ChoiceFormat : send ( \"There {0,choice,0#are no files|1#is one file|1<are {0,number,integer} files}.\" , 2 ) Par ailleurs, Tock met \u00e0 disposition une extension by pour les dates qui permet d'indiquer un format dans les param\u00e8tres : send ( \"Departure at {0}\" , departureDateTime by timeFormat )","title":"Format support\u00e9"},{"location":"i18n/#locale-de-lutilisateur","text":"Quand c'est possible, la locale de l'utilisateur est import\u00e9e de celle de son compte. Par exemple, si le compte d'un utilisateur Messenger est configur\u00e9 en fran\u00e7ais, le fran\u00e7ais sera automatiquement utilis\u00e9 comme locale par Tock. Si il n'y a pas d'indication de locale, c'est la valeur defaultLocale qui est pris en compte. Il est possible de modifier cette valeur par d\u00e9faut avec la propri\u00e9t\u00e9 -Dtock_default_locale=fr Enfin il est possible de modifier la locale de l'utilisateur dans le bot lui-m\u00eame : userPreferences . locale = Locale . FRENCH","title":"Locale de l'utilisateur"},{"location":"i18n/#points-dattention","text":"Le module d'internationalisation de Tock est efficace, mais certaines pratiques, pourtant intuitives en Kotlin, sont \u00e0 bannir sous peine de mauvaises surprises. Par exemple, ce code fonctionne parfaitement bien avec le module i18n d\u00e9sactiv\u00e9. send ( \"There are $nb files\" ) //DANGER!! mais pose probl\u00e8me si il est activ\u00e9. En effet, un nouveau libell\u00e9 sera cr\u00e9\u00e9 pour chaque valeur diff\u00e9rente de la variable nb ! Si il est n\u00e9cessaire d'envoyer des r\u00e9ponses \"\u00e0 ne pas traduire\", utilisez les m\u00e9thodes BotBus.sendRaw , BotBus.endRaw ou String.raw send ( \"There are $nb files\" . raw ) //CORRECT send ( \"There are {0} files\" , nb ) //FORMAT A SUIVRE Le risque de collision entre deux libell\u00e9s est faible puisque l'intention principale de la story fait partie de la cl\u00e9. Si vous souhaitez cependant \u00e9viter tout risque, vous pouvez utiliser la m\u00e9thode i18nKey : send ( i18nKey ( \"my_unique_key\" , \"There are {0} files\" , nb ))","title":"Points d'attention"},{"location":"i18n/#tester-linternationalisation","text":"Un exemple de dispositif de test est disponible dans le code source du bot d'exemple Il est n\u00e9cessaire d'\u00e9tendre l'extension de test pour ensuite indiquer la correspondance des libell\u00e9s \u00e0 tester. Il ne reste plus qu'\u00e0 indiquer la locale souhait\u00e9e : @Test fun `search story asks for departure date WHEN there is a destination and an origin but no departure date in context` () { ext . newRequest ( \"Recherche\" , search , locale = Locale . FRENCH ) { destination = lille origin = paris run () firstAnswer . assertText ( \"Quand souhaitez-vous partir?\" ) } }","title":"Tester l'internationalisation"},{"location":"i18n/#interface-dadministration","text":"","title":"Interface d'administration"},{"location":"i18n/#les-differentes-variantes","text":"Chaque libell\u00e9 a une valeur par d\u00e9faut pour chaque langue du bot. Il est aussi possible d'indiquer des r\u00e9ponses sp\u00e9cifiques : par type de connecteur (Messenger, Google Assistant, Slack, etc.) par type d'interface (Texte ou voix) - c'est utile par exemple dans le cas de Google Assistant pour supporter les cas des parcours voix uniquement. Enfin, vous pouvez sp\u00e9cifier des alternatives . Dans ce cas, le bot utilise une des alternatives possible au hasard, \u00e0 chaque fois qu'il envoie une r\u00e9ponse \u00e0 l'utilisateur.","title":"Les diff\u00e9rentes variantes"},{"location":"i18n/#import-et-export-des-donnees","text":"Une fonctionnalit\u00e9 d'import et d'export des libell\u00e9s au format json ou csv est disponible. Dans le cas d'un import, seuls les libell\u00e9s indiqu\u00e9s comme valid\u00e9s sont pris en compte.","title":"Import et export des donn\u00e9es"},{"location":"installation/","text":"Installer et configurer Tock en production \u00b6 Composants \u00b6 Tock est compos\u00e9 par d\u00e9faut de plusieurs images dockers et d'une base de donn\u00e9e, MongoDB . Un exemple de configuration compl\u00e8te sous forme de fichier docker-compose est disponible dans le projet tock-docker : docker-compose-bot-open-data.yml Si vous souhaitez utiliser docker-compose en production, merci de lire cet article et de revoir la configuration, qui est uniquement donn\u00e9e dans le projet tock-docker \u00e0 titre d'exemple d'environnement de d\u00e9velopement. En particulier, la configuration des instances MongoDB devra \u00eatre revue attentivement. MongoDB \u00b6 La base Mongo doit \u00eatre configur\u00e9e \"en replica set\", c'est \u00e0 dire avec au minimum 3 instances d\u00e9ploy\u00e9es. C'est obligatoire car Tock utilise la fonctionnalit\u00e9 des Change Streams qui a comme pr\u00e9-requis l'installation en replica set. Il s'agit \u00e9galement d'une bonne pratique afin d'assurer une haute disponibilit\u00e9 de la base de donn\u00e9es. Un tutoriel d'installation en replica set est disponible sur le site de MongoDB. Liste et r\u00f4les des images dockers \u00b6 Voici les images composants Tock. Aucune de ces images ne doit \u00eatre expos\u00e9e \u00e0 l'ext\u00e9rieur par d\u00e9faut. tock/bot_admin : l'interface d'administration de Tock. tock/kotlin_compiler : Une image docker facultative qui permet de compiler les scripts du bot via l'interface d'administration. tock/build_worker : L'image docker qui permet de reconstruire les mod\u00e8les NLP quand cela se r\u00e9v\u00e8le n\u00e9cessaire. tock/nlp_api Permet au bot d'analyser les phrases \u00e0 partir des mod\u00e8les construits via l'interface d'administration. tock/bot_api Permet de d\u00e9velopper un bot en mode \"API\". Met \u00e0 disposition une API qui sera utilis\u00e9e pour le d\u00e9veloppement du ou des bots. tock/duckling Permet d'analyser et de valoriser les dates et les types primitifs en utilisant le projet duckling . Enfin bien entendu, il est n\u00e9cessaire d'installer une image repr\u00e9sentant le bot lui-m\u00eame, image qui doit \u00eatre accessible de l'ext\u00e9rieur. Un exemple de configuration de cette derni\u00e8re image se trouve dans le fichier docker-compose-bot-open-data.yml . Sch\u00e9mas des flux \u00b6 Pour une stack uniquement NLU : Pour une stack exposant l'API BOT : Pour une stack int\u00e9grant un Bot Tock : Recommandations \u00b6 Configuration minimale requise \u00b6 Le param\u00e8tre principal \u00e0 surveiller est la m\u00e9moire vive disponible. En particulier, plus vos mod\u00e8les sont importants, plus il sera n\u00e9cessaire d'augmenter la m\u00e9moire pour reconstruire les mod\u00e8les dans l'image tock/build_worker . Pour donner un ordre de grandeur, un mod\u00e8le de 50000 phrases avec plusieurs intentions comportant une vingtaine d'entit\u00e9s chaque n\u00e9cessitera de provisionner environ 8Go de RAM pour l'image tock/build_worker . Cependant des mod\u00e8les importants, mais avec peu d'entit\u00e9s, tiennent facilement en 1Go de RAM. Configuration de la m\u00e9moire des JVMs \u00b6 Pour garantir que les instances dockers ne d\u00e9passent pas la m\u00e9moire disponible, il est recommand\u00e9 de limiter la m\u00e9moire disponible pour la JVM en suivant l'exemple suivant: JAVA_ARGS =- Xmx1g - XX : MaxMetaspaceSize = 256 m Haute disponibilit\u00e9 \u00b6 Autant il est important de s'assurer qu'une seule instance est install\u00e9e pour tock/build_worker - une seule instance est \u00e9galement recommand\u00e9e pour tock/bot_admin et tock/kotlin_compiler -, autant il est recommand\u00e9 d'installer plusieurs instances du bot mais \u00e9galement de tock/nlp_api et de tock/duckling afin de s'assurer d'une haute disponibilit\u00e9. A forte charge - nous avons exp\u00e9riment\u00e9 plus de 80 req/s sur nos propres bots - le facteur limitant devient la base de donn\u00e9es MongoDB, qu'il faut alors redimensionner en cons\u00e9quence quand le besoin s'en fait sentir. Authentification \u00b6 Tock supporte plusieurs syst\u00e8mes d'authentification pour l'interface d'administration. Il utilise les librairies vert.x correspondantes. Voici les syst\u00e8mes disponibles par d\u00e9faut : Un mod\u00e8le \"par propri\u00e9t\u00e9\", qui est utilis\u00e9 par d\u00e9faut. Le code est disponible ici : PropertyBasedAuthProvider Un mod\u00e8le OAuth2 dont un exemple est donn\u00e9 par la classe GithubOAuthProvider Un mod\u00e8le bas\u00e9 sur un token JWT pour une configuration Aws: AWSJWTAuthProvider Si ces mod\u00e8les ne correspondent pas \u00e0 votre besoin, il est relativement simple d'en d\u00e9velopper d'autres en se basant sur les exemples ci-dessus. N'h\u00e9sitez pas \u00e0 contribuer au projet et \u00e0 nous contacter pour toute question! Configuration de proxy http \u00b6 L'ajout des propri\u00e9t\u00e9s syst\u00e8me java correspondantes https.proxyHost , http.proxyHost et http.nonProxyHosts est la m\u00e9thode recommand\u00e9e pour configurer un proxy. Encryption et Obfuscation \u00b6 Encryption \u00b6 Il est recommand\u00e9 de d\u00e9ployer vos MongoDB en mode encrypt\u00e9 . Vous pouvez cependant ajouter une encryption applicative facultative de certains champs en base de donn\u00e9es. C'est le r\u00f4le de la propri\u00e9t\u00e9 tock_encrypt_pass qui vous permet d'indiquer un mot de passe permettant d'encrypter et de d\u00e9crypter ces champs - par d\u00e9faut Tock encrypte toutes les donn\u00e9es utilisateurs jug\u00e9es sensibles si ce mot de passe est sp\u00e9cifi\u00e9. Pour plus de d\u00e9tails, consultez le code source . Obfuscation \u00b6 Par ailleurs, il peut \u00eatre souhaitable que certaines phrases soient affich\u00e9es dans les logs ou dans l'interface d'administration de mani\u00e8re obfusqu\u00e9e . Ce serait par exemple le cas de num\u00e9ros confidentiels de cartes de fid\u00e9lit\u00e9 qui ne devraient \u00eatre lues, ni par vos administrateurs syst\u00e8mes, ni par les utilisateurs de l'interface d'administration. Tock met \u00e0 disposition un syst\u00e8me bas\u00e9 sur les expressions r\u00e9guli\u00e8res dont l'interface de base est StringObfuscator . Monitoring \u00b6 Logs \u00b6 Tock utilise SLF4J . Ligne de vie \u00b6 L'url /healthcheck renvoie une code HTTP 200 si tout est correct. Pour certaines images, le ligne de vie peut ne pas \u00eatre pr\u00e9sente \u00e0 la racine. En particulier : Pour tock/admin , la ligne de vie est localis\u00e9e par d\u00e9faut dans /rest/admin/healthcheck Pour tock/nlp_api , la ligne de vie est /rest/nlp/healthcheck Contact \u00b6 Pour toute question ou remarque, n'h\u00e9sitez pas \u00e0 nous contacter sur gitter .","title":"Installation de Tock"},{"location":"installation/#installer-et-configurer-tock-en-production","text":"","title":"Installer et configurer Tock en production"},{"location":"installation/#composants","text":"Tock est compos\u00e9 par d\u00e9faut de plusieurs images dockers et d'une base de donn\u00e9e, MongoDB . Un exemple de configuration compl\u00e8te sous forme de fichier docker-compose est disponible dans le projet tock-docker : docker-compose-bot-open-data.yml Si vous souhaitez utiliser docker-compose en production, merci de lire cet article et de revoir la configuration, qui est uniquement donn\u00e9e dans le projet tock-docker \u00e0 titre d'exemple d'environnement de d\u00e9velopement. En particulier, la configuration des instances MongoDB devra \u00eatre revue attentivement.","title":"Composants"},{"location":"installation/#mongodb","text":"La base Mongo doit \u00eatre configur\u00e9e \"en replica set\", c'est \u00e0 dire avec au minimum 3 instances d\u00e9ploy\u00e9es. C'est obligatoire car Tock utilise la fonctionnalit\u00e9 des Change Streams qui a comme pr\u00e9-requis l'installation en replica set. Il s'agit \u00e9galement d'une bonne pratique afin d'assurer une haute disponibilit\u00e9 de la base de donn\u00e9es. Un tutoriel d'installation en replica set est disponible sur le site de MongoDB.","title":"MongoDB"},{"location":"installation/#liste-et-roles-des-images-dockers","text":"Voici les images composants Tock. Aucune de ces images ne doit \u00eatre expos\u00e9e \u00e0 l'ext\u00e9rieur par d\u00e9faut. tock/bot_admin : l'interface d'administration de Tock. tock/kotlin_compiler : Une image docker facultative qui permet de compiler les scripts du bot via l'interface d'administration. tock/build_worker : L'image docker qui permet de reconstruire les mod\u00e8les NLP quand cela se r\u00e9v\u00e8le n\u00e9cessaire. tock/nlp_api Permet au bot d'analyser les phrases \u00e0 partir des mod\u00e8les construits via l'interface d'administration. tock/bot_api Permet de d\u00e9velopper un bot en mode \"API\". Met \u00e0 disposition une API qui sera utilis\u00e9e pour le d\u00e9veloppement du ou des bots. tock/duckling Permet d'analyser et de valoriser les dates et les types primitifs en utilisant le projet duckling . Enfin bien entendu, il est n\u00e9cessaire d'installer une image repr\u00e9sentant le bot lui-m\u00eame, image qui doit \u00eatre accessible de l'ext\u00e9rieur. Un exemple de configuration de cette derni\u00e8re image se trouve dans le fichier docker-compose-bot-open-data.yml .","title":"Liste et r\u00f4les des images dockers"},{"location":"installation/#schemas-des-flux","text":"Pour une stack uniquement NLU : Pour une stack exposant l'API BOT : Pour une stack int\u00e9grant un Bot Tock :","title":"Sch\u00e9mas des flux"},{"location":"installation/#recommandations","text":"","title":"Recommandations"},{"location":"installation/#configuration-minimale-requise","text":"Le param\u00e8tre principal \u00e0 surveiller est la m\u00e9moire vive disponible. En particulier, plus vos mod\u00e8les sont importants, plus il sera n\u00e9cessaire d'augmenter la m\u00e9moire pour reconstruire les mod\u00e8les dans l'image tock/build_worker . Pour donner un ordre de grandeur, un mod\u00e8le de 50000 phrases avec plusieurs intentions comportant une vingtaine d'entit\u00e9s chaque n\u00e9cessitera de provisionner environ 8Go de RAM pour l'image tock/build_worker . Cependant des mod\u00e8les importants, mais avec peu d'entit\u00e9s, tiennent facilement en 1Go de RAM.","title":"Configuration minimale requise"},{"location":"installation/#configuration-de-la-memoire-des-jvms","text":"Pour garantir que les instances dockers ne d\u00e9passent pas la m\u00e9moire disponible, il est recommand\u00e9 de limiter la m\u00e9moire disponible pour la JVM en suivant l'exemple suivant: JAVA_ARGS =- Xmx1g - XX : MaxMetaspaceSize = 256 m","title":"Configuration de la m\u00e9moire des JVMs"},{"location":"installation/#haute-disponibilite","text":"Autant il est important de s'assurer qu'une seule instance est install\u00e9e pour tock/build_worker - une seule instance est \u00e9galement recommand\u00e9e pour tock/bot_admin et tock/kotlin_compiler -, autant il est recommand\u00e9 d'installer plusieurs instances du bot mais \u00e9galement de tock/nlp_api et de tock/duckling afin de s'assurer d'une haute disponibilit\u00e9. A forte charge - nous avons exp\u00e9riment\u00e9 plus de 80 req/s sur nos propres bots - le facteur limitant devient la base de donn\u00e9es MongoDB, qu'il faut alors redimensionner en cons\u00e9quence quand le besoin s'en fait sentir.","title":"Haute disponibilit\u00e9"},{"location":"installation/#authentification","text":"Tock supporte plusieurs syst\u00e8mes d'authentification pour l'interface d'administration. Il utilise les librairies vert.x correspondantes. Voici les syst\u00e8mes disponibles par d\u00e9faut : Un mod\u00e8le \"par propri\u00e9t\u00e9\", qui est utilis\u00e9 par d\u00e9faut. Le code est disponible ici : PropertyBasedAuthProvider Un mod\u00e8le OAuth2 dont un exemple est donn\u00e9 par la classe GithubOAuthProvider Un mod\u00e8le bas\u00e9 sur un token JWT pour une configuration Aws: AWSJWTAuthProvider Si ces mod\u00e8les ne correspondent pas \u00e0 votre besoin, il est relativement simple d'en d\u00e9velopper d'autres en se basant sur les exemples ci-dessus. N'h\u00e9sitez pas \u00e0 contribuer au projet et \u00e0 nous contacter pour toute question!","title":"Authentification"},{"location":"installation/#configuration-de-proxy-http","text":"L'ajout des propri\u00e9t\u00e9s syst\u00e8me java correspondantes https.proxyHost , http.proxyHost et http.nonProxyHosts est la m\u00e9thode recommand\u00e9e pour configurer un proxy.","title":"Configuration de proxy http"},{"location":"installation/#encryption-et-obfuscation","text":"","title":"Encryption et Obfuscation"},{"location":"installation/#encryption","text":"Il est recommand\u00e9 de d\u00e9ployer vos MongoDB en mode encrypt\u00e9 . Vous pouvez cependant ajouter une encryption applicative facultative de certains champs en base de donn\u00e9es. C'est le r\u00f4le de la propri\u00e9t\u00e9 tock_encrypt_pass qui vous permet d'indiquer un mot de passe permettant d'encrypter et de d\u00e9crypter ces champs - par d\u00e9faut Tock encrypte toutes les donn\u00e9es utilisateurs jug\u00e9es sensibles si ce mot de passe est sp\u00e9cifi\u00e9. Pour plus de d\u00e9tails, consultez le code source .","title":"Encryption"},{"location":"installation/#obfuscation","text":"Par ailleurs, il peut \u00eatre souhaitable que certaines phrases soient affich\u00e9es dans les logs ou dans l'interface d'administration de mani\u00e8re obfusqu\u00e9e . Ce serait par exemple le cas de num\u00e9ros confidentiels de cartes de fid\u00e9lit\u00e9 qui ne devraient \u00eatre lues, ni par vos administrateurs syst\u00e8mes, ni par les utilisateurs de l'interface d'administration. Tock met \u00e0 disposition un syst\u00e8me bas\u00e9 sur les expressions r\u00e9guli\u00e8res dont l'interface de base est StringObfuscator .","title":"Obfuscation"},{"location":"installation/#monitoring","text":"","title":"Monitoring"},{"location":"installation/#logs","text":"Tock utilise SLF4J .","title":"Logs"},{"location":"installation/#ligne-de-vie","text":"L'url /healthcheck renvoie une code HTTP 200 si tout est correct. Pour certaines images, le ligne de vie peut ne pas \u00eatre pr\u00e9sente \u00e0 la racine. En particulier : Pour tock/admin , la ligne de vie est localis\u00e9e par d\u00e9faut dans /rest/admin/healthcheck Pour tock/nlp_api , la ligne de vie est /rest/nlp/healthcheck","title":"Ligne de vie"},{"location":"installation/#contact","text":"Pour toute question ou remarque, n'h\u00e9sitez pas \u00e0 nous contacter sur gitter .","title":"Contact"},{"location":"kdoc/","text":"La documentation KDoc est mise \u00e0 disposition .","title":"KDoc"},{"location":"pour-commencer/","text":"Commencer \u00e0 utiliser Tock \u00b6 Plateforme de d\u00e9monstration \u00b6 Le plus simple est de d\u00e9marrer en utilisant la plateforme de d\u00e9monstration . Cette plateforme vous permet de tester simplement les diff\u00e9rentes fonctionnalit\u00e9s de Tock. N'h\u00e9sitez pas \u00e0 nous faire vos retours via gitter ou en signalant une anomalie . Elle permet de cr\u00e9er des mod\u00e8les NLU (pour Natural Language Understanding) et de d\u00e9velopper des bots via l'API \"BOT\" de Tock. Pour plus de d\u00e9tails, veuillez consulter les chapitres correspondants : Construire le mod\u00e8le D\u00e9velopper un Assistant D\u00e9velopper via API Images Docker \u00b6 Si vous souhaitez ne pas d\u00e9velopper un assistant en utilisation l'API BOT ( c'est \u00e0 dire en d\u00e9veloppant un assistant \"Tock\"), ou si vous souhaitez mettre en plateforme de production, vous aurez besoin d'installer Tock sur vos serveurs. Des images docker sont mises \u00e0 disposition pour faciliter le d\u00e9marrage. Ces images sont disponibles dans le Hub Docker . Le code source utilis\u00e9 pour construire ces images, ainsi que les fichiers docker-compose utilis\u00e9s pour d\u00e9marrer l'ensemble de la boite \u00e0 outils Tock sont disponibles dans le repository github https://github.com/voyages-sncf-technologies/tock-docker . D\u00e9marrer l'interface d'administration \u00b6 #get the last docker-compose file curl -o docker-compose.yml https://raw.githubusercontent.com/voyages-sncf-technologies/tock-docker/master/docker-compose.yml #get the script to start mongo in replicaset mode mkdir -p scripts && curl -o scripts/setup.sh https://raw.githubusercontent.com/voyages-sncf-technologies/tock-docker/master/scripts/setup.sh && chmod +x scripts/setup.sh #get the last tag curl -o .env https://raw.githubusercontent.com/voyages-sncf-technologies/tock-docker/master/.env #launch the stack docker-compose up L'interface d'administration NLP est maintenant disponible sur le port 80 : http://localhost l'identifiant par d\u00e9faut est admin@app.com et le mot de passe password . Menu de l'interface d'administration \u00b6 Le menu \u00e0 gauche permet d'acc\u00e9der aux diff\u00e9rentes fonctionnalit\u00e9s. Le menu Configuration permet de cr\u00e9er de nouveaux mod\u00e8le et de param\u00e9trer les options importantes. Les menus NLP et NLP QA sont d\u00e9di\u00e9s \u00e0 la construction de mod\u00e8les. Les menus Build , Test et Monitoring sont eux utilis\u00e9s dans le cadre de la construction de bots ou d'assistants. Commencer le d\u00e9veloppement d'un Assistant via API \u00b6 Un exemple de configuration est disponible ici dans le projet tock-docker sous le nom de docker-compose-bot.yml. Veuillez consulter la documentation correspondante . Un exemple d'Assistant Tock \u00b6 Un bot d'exemple utilisant Tock est mis \u00e0 disposition sur github : https://github.com/voyages-sncf-technologies/tock-bot-open-data . Il se base sur les API Open Data de la SNCF , et pr\u00e9sente des fonctionnalit\u00e9s minimales permettant de d\u00e9montrer l\u2019usage de Tock. Il s'agit d'un bon point de d\u00e9part, puisque il comporte \u00e9galement un mod\u00e8le NLP tr\u00e8s simple. Bien entendu, comme le mod\u00e8le n'est pas complet, la qualit\u00e9 du bot est faible, mais suffit cependant \u00e0 d\u00e9montrer le principe de l'outil. Dans la suite de la documentation, nous nous r\u00e9f\u00e9rerons \u00e0 cet exemple pour couvrir l'ensemble des fonctionnalit\u00e9s. Stack docker \u00b6 Une image docker est mis \u00e0 disposition pour le lancer directement. Les instructions pour la d\u00e9marrer sont pr\u00e9cis\u00e9es dans le projet github contenant les images docker .","title":"Pour commencer"},{"location":"pour-commencer/#commencer-a-utiliser-tock","text":"","title":"Commencer \u00e0 utiliser Tock"},{"location":"pour-commencer/#plateforme-de-demonstration","text":"Le plus simple est de d\u00e9marrer en utilisant la plateforme de d\u00e9monstration . Cette plateforme vous permet de tester simplement les diff\u00e9rentes fonctionnalit\u00e9s de Tock. N'h\u00e9sitez pas \u00e0 nous faire vos retours via gitter ou en signalant une anomalie . Elle permet de cr\u00e9er des mod\u00e8les NLU (pour Natural Language Understanding) et de d\u00e9velopper des bots via l'API \"BOT\" de Tock. Pour plus de d\u00e9tails, veuillez consulter les chapitres correspondants : Construire le mod\u00e8le D\u00e9velopper un Assistant D\u00e9velopper via API","title":"Plateforme de d\u00e9monstration"},{"location":"pour-commencer/#images-docker","text":"Si vous souhaitez ne pas d\u00e9velopper un assistant en utilisation l'API BOT ( c'est \u00e0 dire en d\u00e9veloppant un assistant \"Tock\"), ou si vous souhaitez mettre en plateforme de production, vous aurez besoin d'installer Tock sur vos serveurs. Des images docker sont mises \u00e0 disposition pour faciliter le d\u00e9marrage. Ces images sont disponibles dans le Hub Docker . Le code source utilis\u00e9 pour construire ces images, ainsi que les fichiers docker-compose utilis\u00e9s pour d\u00e9marrer l'ensemble de la boite \u00e0 outils Tock sont disponibles dans le repository github https://github.com/voyages-sncf-technologies/tock-docker .","title":"Images Docker"},{"location":"pour-commencer/#demarrer-linterface-dadministration","text":"#get the last docker-compose file curl -o docker-compose.yml https://raw.githubusercontent.com/voyages-sncf-technologies/tock-docker/master/docker-compose.yml #get the script to start mongo in replicaset mode mkdir -p scripts && curl -o scripts/setup.sh https://raw.githubusercontent.com/voyages-sncf-technologies/tock-docker/master/scripts/setup.sh && chmod +x scripts/setup.sh #get the last tag curl -o .env https://raw.githubusercontent.com/voyages-sncf-technologies/tock-docker/master/.env #launch the stack docker-compose up L'interface d'administration NLP est maintenant disponible sur le port 80 : http://localhost l'identifiant par d\u00e9faut est admin@app.com et le mot de passe password .","title":"D\u00e9marrer l'interface d'administration"},{"location":"pour-commencer/#menu-de-linterface-dadministration","text":"Le menu \u00e0 gauche permet d'acc\u00e9der aux diff\u00e9rentes fonctionnalit\u00e9s. Le menu Configuration permet de cr\u00e9er de nouveaux mod\u00e8le et de param\u00e9trer les options importantes. Les menus NLP et NLP QA sont d\u00e9di\u00e9s \u00e0 la construction de mod\u00e8les. Les menus Build , Test et Monitoring sont eux utilis\u00e9s dans le cadre de la construction de bots ou d'assistants.","title":"Menu de l'interface d'administration"},{"location":"pour-commencer/#commencer-le-developpement-dun-assistant-via-api","text":"Un exemple de configuration est disponible ici dans le projet tock-docker sous le nom de docker-compose-bot.yml. Veuillez consulter la documentation correspondante .","title":"Commencer le d\u00e9veloppement d'un Assistant via API"},{"location":"pour-commencer/#un-exemple-dassistant-tock","text":"Un bot d'exemple utilisant Tock est mis \u00e0 disposition sur github : https://github.com/voyages-sncf-technologies/tock-bot-open-data . Il se base sur les API Open Data de la SNCF , et pr\u00e9sente des fonctionnalit\u00e9s minimales permettant de d\u00e9montrer l\u2019usage de Tock. Il s'agit d'un bon point de d\u00e9part, puisque il comporte \u00e9galement un mod\u00e8le NLP tr\u00e8s simple. Bien entendu, comme le mod\u00e8le n'est pas complet, la qualit\u00e9 du bot est faible, mais suffit cependant \u00e0 d\u00e9montrer le principe de l'outil. Dans la suite de la documentation, nous nous r\u00e9f\u00e9rerons \u00e0 cet exemple pour couvrir l'ensemble des fonctionnalit\u00e9s.","title":"Un exemple d'Assistant Tock"},{"location":"pour-commencer/#stack-docker","text":"Une image docker est mis \u00e0 disposition pour le lancer directement. Les instructions pour la d\u00e9marrer sont pr\u00e9cis\u00e9es dans le projet github contenant les images docker .","title":"Stack docker"},{"location":"presentation-du-bot-open-data/","text":"Le Bot Open Data \u00b6 Un bon point de d\u00e9part est le code source du bot Open Data , qui comme son nom l'indique, utilise les APIs Open Data de la SNCF . Suivez les instructions pr\u00e9sentes dans le README du projet pour d\u00e9marrer le bot dans l'IDE (ne configurez pas Messenger ou Google Assistant \u00e0 ce stade), puis connectez vous \u00e0 l'interface d'administration. Le bot est d'ors et d\u00e9j\u00e0 testable.","title":"Pr\u00e9sentation du Bot Open Data"},{"location":"presentation-du-bot-open-data/#le-bot-open-data","text":"Un bon point de d\u00e9part est le code source du bot Open Data , qui comme son nom l'indique, utilise les APIs Open Data de la SNCF . Suivez les instructions pr\u00e9sentes dans le README du projet pour d\u00e9marrer le bot dans l'IDE (ne configurez pas Messenger ou Google Assistant \u00e0 ce stade), puis connectez vous \u00e0 l'interface d'administration. Le bot est d'ors et d\u00e9j\u00e0 testable.","title":"Le Bot Open Data"},{"location":"tester/","text":"Utiliser le framework de test \u00b6 Tock met \u00e0 disposition des extensions pour tester le bot unitairement. Pour les utiliser, il est n\u00e9cessaire d'ajouter la librairie bot-test \u00e0 votre projet. Avec Maven : <dependency> <groupId> fr.vsct.tock </groupId> <artifactId> bot-test </artifactId> <version> 19.3.2 </version> <scope> test </scope> </dependency> ou Gradle : testCompile 'fr.vsct.tock:bot-test:19.3.2' L'ensemble de ce framework est document\u00e9 au format KDoc ici . Ecrire un test simple \u00b6 L'ensemble des exemples suivants utilisent JUnit5 . Une extension d\u00e9di\u00e9e \u00e0 Tock et JUnit5 est disponible . @RegisterExtension @JvmField val ext = TockJUnit5Extension () Afin de tester la story greetings du bot Open Data, il suffit d'utiliser la m\u00e9thode ext.send() qui permet d'obtenir un mock du bus conversationnel. Le test unitaire s'\u00e9crit alors ainsi : @Test fun `greetings story displays welcome message WHEN locale is fr` () { ext . send ( locale = Locale . FRENCH ) { firstAnswer . assertText ( \"Bienvenue chez le Bot Open Data Sncf! :)\" ) secondAnswer . assertText ( \"Il s'agit d'un bot de d\u00e9monstration du framework Tock : https://github.com/voyages-sncf-technologies/tock\" ) } } Comme le connector par d\u00e9faut est celui de Messenger, il est possible de tester de la m\u00eame mani\u00e8re le message sp\u00e9cifique \u00e0 Messenger : lastAnswer . assertMessage ( buttonsTemplate ( \"Il est volontairement tr\u00e8s limit\u00e9, mais demandez lui un itin\u00e9raire ou les d\u00e9parts \u00e0 partir d'une gare et constatez le r\u00e9sultat! :)\" , postbackButton ( \"Itin\u00e9raires\" , search ), postbackButton ( \"D\u00e9parts\" , Departures ), postbackButton ( \"Arriv\u00e9es\" , Arrivals ) ) ) Pour tester le message sp\u00e9cifique \u00e0 Google Assistant (ou tout autre connecteur), il est n\u00e9cessaire de sp\u00e9cifier le connecteur que l'on souhaite tester : ext . send ( connectorType = gaConnectorType , locale = Locale . FRENCH ) { firstAnswer . assertText ( \"Bienvenue chez le Bot Open Data Sncf! :)\" ) secondAnswer . assertText ( \"Il s'agit d'un bot de d\u00e9monstration du framework Tock : https://github.com/voyages-sncf-technologies/tock\" ) lastAnswer . assertMessage ( gaMessage ( \"Il est volontairement tr\u00e8s limit\u00e9, mais demandez lui un itin\u00e9raire ou les d\u00e9parts \u00e0 partir d'une gare et constatez le r\u00e9sultat! :)\" , \"Itin\u00e9raires\" , \"D\u00e9parts\" , \"Arriv\u00e9es\" ) ) } Tester une Story sp\u00e9cifique \u00b6 Dans les exemples pr\u00e9c\u00e9dents, il n'\u00e9tait pas n\u00e9cessaire d'indiquer la story \u00e0 tester ( greetings \u00e9tant la story par d\u00e9faut). Supposons que nous souhaitons la story search , nous devons pr\u00e9ciser la story \u00e0 tester de la mani\u00e8re suivante : @Test fun `search story asks for destination WHEN there is no destination in context` () { ext . send ( intent = search , locale = Locale . FRENCH ) { firstAnswer . assertText ( \"Pour quelle destination?\" ) } } Tester un dialogue \u00b6 Il est possible de simuler un dialogue complet. Par exemple, on simule ici que l'utilisateur indique la destination, puis l'origine : @Test fun `search story asks for origin WHEN there is a destination but no origin in context` () { ext . send ( \"Je voudrais rechercher un itin\u00e9raire\" , search , locale = Locale . FRENCH ) { firstAnswer . assertText ( \"Pour quelle destination?\" ) } ext . send ( \"Lille\" , indicate_location , locationEntity setTo lille ) { firstBusAnswer . assertText ( \"Pour quelle origine?\" ) } ext . send ( \"Paris\" , indicate_location , locationEntity setTo paris ) { firstBusAnswer . assertText ( \"Quand souhaitez-vous partir?\" ) } } Le texte en premier param\u00e8tre de la m\u00e9thode send est simplement indicatif, pour aider \u00e0 la compr\u00e9hension des tests. Les param\u00e8tres suivants permettent de d\u00e9finir comment le NLP va analyser la phrase. Par exemple : private val lille = PlaceValue ( SncfPlace ( \"stop_area\" , 90 , \"Lille Europe\" , \"Lille Europe (Lille)\" , \"stop_area:OCE:SA:87223263\" , Coordinates ( 50.638861 , 3.075774 ) ) ) ext . send ( \"Lille\" , indicate_location , locationEntity setTo lille ) permet d'indiquer que la phrase \"Lille\" est cat\u00e9goris\u00e9e comme une intention indicate_location et avec une valeur pour l'entit\u00e9 location qui va \u00eatre la localisation lille Enfin il est possible de modifier toutes les valeurs du bus mock\u00e9 \u00e0 l'initialisation. Dans l'exemple suivant, on simule l'intention secondaire indicate_location afin d'indiquer l'origine : @Test fun `search story asks for departure date WHEN there is a destination and an origin but no departure date in context` () { ext . newRequest ( \"Recherche\" , search , locale = Locale . FRENCH ) { destination = lille origin = paris run () firstAnswer . assertText ( \"Quand souhaitez-vous partir?\" ) } } Les variables origin et destination sont mises \u00e0 jour, puis un appel au bus est simul\u00e9 avec la fonction run() .","title":"Tester"},{"location":"tester/#utiliser-le-framework-de-test","text":"Tock met \u00e0 disposition des extensions pour tester le bot unitairement. Pour les utiliser, il est n\u00e9cessaire d'ajouter la librairie bot-test \u00e0 votre projet. Avec Maven : <dependency> <groupId> fr.vsct.tock </groupId> <artifactId> bot-test </artifactId> <version> 19.3.2 </version> <scope> test </scope> </dependency> ou Gradle : testCompile 'fr.vsct.tock:bot-test:19.3.2' L'ensemble de ce framework est document\u00e9 au format KDoc ici .","title":"Utiliser le framework de test"},{"location":"tester/#ecrire-un-test-simple","text":"L'ensemble des exemples suivants utilisent JUnit5 . Une extension d\u00e9di\u00e9e \u00e0 Tock et JUnit5 est disponible . @RegisterExtension @JvmField val ext = TockJUnit5Extension () Afin de tester la story greetings du bot Open Data, il suffit d'utiliser la m\u00e9thode ext.send() qui permet d'obtenir un mock du bus conversationnel. Le test unitaire s'\u00e9crit alors ainsi : @Test fun `greetings story displays welcome message WHEN locale is fr` () { ext . send ( locale = Locale . FRENCH ) { firstAnswer . assertText ( \"Bienvenue chez le Bot Open Data Sncf! :)\" ) secondAnswer . assertText ( \"Il s'agit d'un bot de d\u00e9monstration du framework Tock : https://github.com/voyages-sncf-technologies/tock\" ) } } Comme le connector par d\u00e9faut est celui de Messenger, il est possible de tester de la m\u00eame mani\u00e8re le message sp\u00e9cifique \u00e0 Messenger : lastAnswer . assertMessage ( buttonsTemplate ( \"Il est volontairement tr\u00e8s limit\u00e9, mais demandez lui un itin\u00e9raire ou les d\u00e9parts \u00e0 partir d'une gare et constatez le r\u00e9sultat! :)\" , postbackButton ( \"Itin\u00e9raires\" , search ), postbackButton ( \"D\u00e9parts\" , Departures ), postbackButton ( \"Arriv\u00e9es\" , Arrivals ) ) ) Pour tester le message sp\u00e9cifique \u00e0 Google Assistant (ou tout autre connecteur), il est n\u00e9cessaire de sp\u00e9cifier le connecteur que l'on souhaite tester : ext . send ( connectorType = gaConnectorType , locale = Locale . FRENCH ) { firstAnswer . assertText ( \"Bienvenue chez le Bot Open Data Sncf! :)\" ) secondAnswer . assertText ( \"Il s'agit d'un bot de d\u00e9monstration du framework Tock : https://github.com/voyages-sncf-technologies/tock\" ) lastAnswer . assertMessage ( gaMessage ( \"Il est volontairement tr\u00e8s limit\u00e9, mais demandez lui un itin\u00e9raire ou les d\u00e9parts \u00e0 partir d'une gare et constatez le r\u00e9sultat! :)\" , \"Itin\u00e9raires\" , \"D\u00e9parts\" , \"Arriv\u00e9es\" ) ) }","title":"Ecrire un test simple"},{"location":"tester/#tester-une-story-specifique","text":"Dans les exemples pr\u00e9c\u00e9dents, il n'\u00e9tait pas n\u00e9cessaire d'indiquer la story \u00e0 tester ( greetings \u00e9tant la story par d\u00e9faut). Supposons que nous souhaitons la story search , nous devons pr\u00e9ciser la story \u00e0 tester de la mani\u00e8re suivante : @Test fun `search story asks for destination WHEN there is no destination in context` () { ext . send ( intent = search , locale = Locale . FRENCH ) { firstAnswer . assertText ( \"Pour quelle destination?\" ) } }","title":"Tester une Story sp\u00e9cifique"},{"location":"tester/#tester-un-dialogue","text":"Il est possible de simuler un dialogue complet. Par exemple, on simule ici que l'utilisateur indique la destination, puis l'origine : @Test fun `search story asks for origin WHEN there is a destination but no origin in context` () { ext . send ( \"Je voudrais rechercher un itin\u00e9raire\" , search , locale = Locale . FRENCH ) { firstAnswer . assertText ( \"Pour quelle destination?\" ) } ext . send ( \"Lille\" , indicate_location , locationEntity setTo lille ) { firstBusAnswer . assertText ( \"Pour quelle origine?\" ) } ext . send ( \"Paris\" , indicate_location , locationEntity setTo paris ) { firstBusAnswer . assertText ( \"Quand souhaitez-vous partir?\" ) } } Le texte en premier param\u00e8tre de la m\u00e9thode send est simplement indicatif, pour aider \u00e0 la compr\u00e9hension des tests. Les param\u00e8tres suivants permettent de d\u00e9finir comment le NLP va analyser la phrase. Par exemple : private val lille = PlaceValue ( SncfPlace ( \"stop_area\" , 90 , \"Lille Europe\" , \"Lille Europe (Lille)\" , \"stop_area:OCE:SA:87223263\" , Coordinates ( 50.638861 , 3.075774 ) ) ) ext . send ( \"Lille\" , indicate_location , locationEntity setTo lille ) permet d'indiquer que la phrase \"Lille\" est cat\u00e9goris\u00e9e comme une intention indicate_location et avec une valeur pour l'entit\u00e9 location qui va \u00eatre la localisation lille Enfin il est possible de modifier toutes les valeurs du bus mock\u00e9 \u00e0 l'initialisation. Dans l'exemple suivant, on simule l'intention secondaire indicate_location afin d'indiquer l'origine : @Test fun `search story asks for departure date WHEN there is a destination and an origin but no departure date in context` () { ext . newRequest ( \"Recherche\" , search , locale = Locale . FRENCH ) { destination = lille origin = paris run () firstAnswer . assertText ( \"Quand souhaitez-vous partir?\" ) } } Les variables origin et destination sont mises \u00e0 jour, puis un appel au bus est simul\u00e9 avec la fonction run() .","title":"Tester un dialogue"}]}